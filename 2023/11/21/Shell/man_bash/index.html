<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>manual of bash | MyBlog</title><meta name="author" content="illyber"><meta name="copyright" content="illyber"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="BASH(1)                     General Commands Manual                           BASH(1)DESCRIPTION   Bash  is  an  sh-compatible  command  language interpreter that executes commands read from the stand">
<meta property="og:type" content="article">
<meta property="og:title" content="manual of bash">
<meta property="og:url" content="https://illyber.github.io/2023/11/21/Shell/man_bash/index.html">
<meta property="og:site_name" content="MyBlog">
<meta property="og:description" content="BASH(1)                     General Commands Manual                           BASH(1)DESCRIPTION   Bash  is  an  sh-compatible  command  language interpreter that executes commands read from the stand">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://illyber-images.oss-cn-chengdu.aliyuncs.com/kuroyukihime-3.jpg">
<meta property="article:published_time" content="2023-11-21T15:22:21.951Z">
<meta property="article:modified_time" content="2023-11-21T15:22:21.954Z">
<meta property="article:author" content="illyber">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://illyber-images.oss-cn-chengdu.aliyuncs.com/kuroyukihime-3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://illyber.github.io/2023/11/21/Shell/man_bash/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'manual of bash',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-21 23:22:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/kuroyukihime-3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/todo/"><i class="fa-fw fas fa-list-alt"></i><span> ToDo</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://illyber-images.oss-cn-chengdu.aliyuncs.com/kuroyukihime-2.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="MyBlog"><span class="site-name">MyBlog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/todo/"><i class="fa-fw fas fa-list-alt"></i><span> ToDo</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">manual of bash</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-21T15:22:21.951Z" title="发表于 2023-11-21 23:22:21">2023-11-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-21T15:22:21.954Z" title="更新于 2023-11-21 23:22:21">2023-11-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Shell/">Shell</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="manual of bash"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="BASH-1-General-Commands-Manual-BASH-1"><a href="#BASH-1-General-Commands-Manual-BASH-1" class="headerlink" title="BASH(1)                     General Commands Manual                           BASH(1)"></a>BASH(1)                     General Commands Manual                           BASH(1)</h1><h1 id="DESCRIPTION"><a href="#DESCRIPTION" class="headerlink" title="DESCRIPTION"></a>DESCRIPTION</h1><pre><code>   Bash  is  an  sh-compatible  command  language interpreter that executes commands read from the standard input or from a file.  Bash also incorporates useful features from the Korn and C shells (ksh and csh).

   Bash is intended to be a conformant implementation of the Shell and Utilities portion of the  IEEE  POSIX  specification
   (IEEE Standard 1003.1).  Bash can be configured to be POSIX-conformant by default.
</code></pre>
<h1 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h1><pre><code>   All of the single-character shell options documented in the description of the set builtin command, including -o, can be
   used as options when the shell is invoked.  In addition, bash interprets the following options when it is invoked:

   -c        If  the  -c  option  is present, then commands are read from the first non-option argument command_string.  If
             there are arguments after the command_string, the first argument is assigned to $0 and any remaining arguments
             are assigned to the positional parameters.  The assignment to $0 sets the name of the shell, which is used  in
             warning and error messages.
   -i        If the -i option is present, the shell is interactive.
   -l        Make bash act as if it had been invoked as a login shell (see INVOCATION below).
   -r        If the -r option is present, the shell becomes restricted (see RESTRICTED SHELL below).
   -s        If  the  -s  option is present, or if no arguments remain after option processing, then commands are read from
             the standard input.  This option allows the positional parameters to be set when invoking an interactive shell
             or when reading input through a pipe.
   -v        Print shell input lines as they are read.
   -x        Print commands and their arguments as they are executed.
   -D        A list of all double-quoted strings preceded by $ is printed on the standard output.  These  are  the  strings
             that  are  subject to language translation when the current locale is not C or POSIX.  This implies the -n op‐
             tion; no commands will be executed.
   [-+]O [shopt_option]
             shopt_option is one of the shell options accepted by the shopt builtin (see SHELL BUILTIN COMMANDS below).  If
             shopt_option is present, -O sets the value of that option; +O unsets it.  If shopt_option is not supplied, the
             names and values of the shell options accepted by shopt are printed on the standard output.  If the invocation
             option is +O, the output is displayed in a format that may be reused as input.
   --        A -- signals the end of options and disables further option  processing.   Any  arguments  after  the  --  are
             treated as filenames and arguments.  An argument of - is equivalent to --.

   Bash also interprets a number of multi-character options.  These options must appear on the command line before the sin‐
   gle-character options to be recognized.

   --debugger
          Arrange  for  the debugger profile to be executed before the shell starts.  Turns on extended debugging mode (see
          the description of the extdebug option to the shopt builtin below).
   --dump-po-strings
          Equivalent to -D, but the output is in the GNU gettext po (portable object) file format.
   --dump-strings
          Equivalent to -D.
   --help Display a usage message on standard output and exit successfully.
   --init-file file
   --rcfile file
          Execute commands from file instead of the system wide initialization file /etc/bash.bashrc and the standard  per‐
          sonal initialization file ~/.bashrc if the shell is interactive (see INVOCATION below).

   --login
          Equivalent to -l.

   --noediting
          Do not use the GNU readline library to read command lines when the shell is interactive.

   --noprofile
          Do  not  read  either  the  system-wide  startup  file  /etc/profile  or any of the personal initialization files
          ~/.bash_profile, ~/.bash_login, or ~/.profile.  By default, bash reads these files when it is invoked as a  login
          shell (see INVOCATION below).

   --norc Do not read and execute the system wide initialization file /etc/bash.bashrc and the personal initialization file
          ~/.bashrc if the shell is interactive.  This option is on by default if the shell is invoked as sh.

   --posix
          Change  the  behavior  of  bash where the default operation differs from the POSIX standard to match the standard
          (posix mode).  See SEE ALSO below for a reference to a document that details how posix mode affects bash&#39;s behav‐
          ior.

   --restricted
          The shell becomes restricted (see RESTRICTED SHELL below).

   --verbose
          Equivalent to -v.

   --version
          Show version information for this instance of bash on the standard output and exit successfully.
</code></pre>
<h1 id="ARGUMENTS"><a href="#ARGUMENTS" class="headerlink" title="ARGUMENTS"></a>ARGUMENTS</h1><pre><code>   If arguments remain after option processing, and neither the -c nor the -s option has been supplied, the first  argument
   is  assumed  to  be  the name of a file containing shell commands.  If bash is invoked in this fashion, $0 is set to the
   name of the file, and the positional parameters are set to the remaining arguments.  Bash reads  and  executes  commands
   from  this  file,  then exits.  Bash&#39;s exit status is the exit status of the last command executed in the script.  If no
   commands are executed, the exit status is 0.  An attempt is first made to open the file in the current  directory,  and,
   if no file is found, then the shell searches the directories in PATH for the script.
</code></pre>
<h1 id="INVOCATION"><a href="#INVOCATION" class="headerlink" title="INVOCATION"></a>INVOCATION</h1><pre><code>   A login shell is one whose first character of argument zero is a -, or one started with the --login option.

   An  interactive  shell  is  one started without non-option arguments (unless -s is specified) and without the -c option, whose standard input and error are both connected to terminals (as determined by isatty(3)), or one started with the  -i option.   PS1  is  set  and $- includes i if bash is interactive, allowing a shell script or a startup file to test this state.

   The following paragraphs describe how bash executes its startup files.  If any of the files exist but  cannot  be  read,
   bash  reports an error.  Tildes are expanded in filenames as described below under Tilde Expansion in the EXPANSION sec‐
   tion.

   When bash is invoked as an interactive login shell, or as a non-interactive shell with  the  --login  option,  it  first
   reads  and  executes  commands  from  the file /etc/profile, if that file exists.  After reading that file, it looks for
   ~/.bash_profile, ~/.bash_login, and ~/.profile, in that order, and reads and executes commands from the first  one  that
   exists and is readable.  The --noprofile option may be used when the shell is started to inhibit this behavior.

   When  an  interactive  login shell exits, or a non-interactive login shell executes the exit builtin command, bash reads
   and executes commands from the file ~/.bash_logout, if it exists.

   When an interactive shell that is not a login shell is started, bash reads and executes commands  from  /etc/bash.bashrc
   and  ~/.bashrc,  if these files exist.  This may be inhibited by using the --norc option.  The --rcfile file option will
   force bash to read and execute commands from file instead of /etc/bash.bashrc and ~/.bashrc.

   When bash is started non-interactively, to run a shell script, for example, it looks for the variable  BASH_ENV  in  the
   environment,  expands  its value if it appears there, and uses the expanded value as the name of a file to read and exe‐
   cute.  Bash behaves as if the following command were executed:
          if [ -n &quot;$BASH_ENV&quot; ]; then . &quot;$BASH_ENV&quot;; fi
   but the value of the PATH variable is not used to search for the filename.

   If bash is invoked with the name sh, it tries to mimic the startup behavior of historical versions of sh as  closely  as
   possible, while conforming to the POSIX standard as well.  When invoked as an interactive login shell, or a non-interac‐
   tive  shell with the --login option, it first attempts to read and execute commands from /etc/profile and ~/.profile, in
   that order.  The --noprofile option may be used to inhibit this behavior.  When invoked as an interactive shell with the
   name sh, bash looks for the variable ENV, expands its value if it is defined, and uses the expanded value as the name of
   a file to read and execute.  Since a shell invoked as sh does not attempt to read and execute commands  from  any  other
   startup  files, the --rcfile option has no effect.  A non-interactive shell invoked with the name sh does not attempt to
   read any other startup files.  When invoked as sh, bash enters posix mode after the startup files are read.

   When bash is started in posix mode, as with the --posix command line option, it follows the POSIX standard  for  startup
   files.   In this mode, interactive shells expand the ENV variable and commands are read and executed from the file whose
   name is the expanded value.  No other startup files are read.

   Bash attempts to determine when it is being run with its standard input connected to a network connection, as when  exe‐
   cuted  by  the  historical remote shell daemon, usually rshd, or the secure shell daemon sshd.  If bash determines it is
   being run non-interactively in this fashion, it reads and executes commands  from  /etc/bash.bashrc  and  ~/.bashrc,  if
   these  files  exist  and  are readable.  It will not do this if invoked as sh.  The --norc option may be used to inhibit
   this behavior, and the --rcfile option may be used to force another file to be read, but neither rshd nor sshd generally
   invoke the shell with those options or allow them to be specified.

   If the shell is started with the effective user (group) id not equal to the real user (group) id, and the -p  option  is
   not  supplied,  no  startup  files  are  read,  shell  functions  are not inherited from the environment, the SHELLOPTS,
   BASHOPTS, CDPATH, and GLOBIGNORE variables, if they appear in the environment, are ignored, and the effective user id is
   set to the real user id.  If the -p option is supplied at invocation, the startup behavior is the same, but  the  effec‐
   tive user id is not reset.
</code></pre>
<h1 id="DEFINITIONS"><a href="#DEFINITIONS" class="headerlink" title="DEFINITIONS"></a>DEFINITIONS</h1><pre><code>   The following definitions are used throughout the rest of this document.
   blank  A space or tab.
   word   A sequence of characters considered as a single unit by the shell.  Also known as a token.
   name   A  word consisting only of alphanumeric characters and underscores, and beginning with an alphabetic character or
          an underscore.  Also referred to as an identifier.
   metacharacter
          A character that, when unquoted, separates words.  One of the following:
          |  &amp; ; ( ) &lt; &gt; space tab newline
   control operator
          A token that performs a control function.  It is one of the following symbols:
          || &amp; &amp;&amp; ; ;; ;&amp; ;;&amp; ( ) | |&amp; &lt;newline&gt;
</code></pre>
<h1 id="RESERVED-WORDS"><a href="#RESERVED-WORDS" class="headerlink" title="RESERVED WORDS"></a>RESERVED WORDS</h1><pre><code>   Reserved words are words that have a special meaning to the shell.  The following words are recognized as reserved  when
   unquoted  and  either  the first word of a command (see SHELL GRAMMAR below), the third word of a case or select command
   (only in is valid), or the third word of a for command (only in and do are valid):

   ! case  coproc  do done elif else esac fi for function if in select then until while &#123; &#125; time [[ ]]
</code></pre>
<h1 id="SHELL-GRAMMAR"><a href="#SHELL-GRAMMAR" class="headerlink" title="SHELL GRAMMAR"></a>SHELL GRAMMAR</h1><pre><code>   This section describes the syntax of the various forms of shell commands.
</code></pre>
<h2 id="Simple-Commands"><a href="#Simple-Commands" class="headerlink" title="Simple Commands"></a>Simple Commands</h2><pre><code>   A simple command is a sequence of optional variable assignments followed by blank-separated words and redirections,  and
   terminated  by a control operator.  The first word specifies the command to be executed, and is passed as argument zero.
   The remaining words are passed as arguments to the invoked command.

   The return value of a simple command is its exit status, or 128+n if the command is terminated by signal n.
</code></pre>
<h2 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h2><pre><code>   A pipeline is a sequence of one or more commands separated by one of the control operators | or |&amp;.  The  format  for  a
   pipeline is:

          [time [-p]] [ ! ] command1 [ [|⎪|&amp;] command2 ... ]

   The standard output of command1 is connected via a pipe to the standard input of command2.  This connection is performed
   before  any redirections specified by the command1(see REDIRECTION below).  If |&amp; is used, command1&#39;s standard error, in
   addition to its standard output, is connected to command2&#39;s standard input through the pipe; it is shorthand for 2&gt;&amp;1 |.
   This implicit redirection of the standard error to the standard output is performed after any redirections specified  by
   command1.

   The  return  status  of  a  pipeline  is the exit status of the last command, unless the pipefail option is enabled.  If
   pipefail is enabled, the pipeline&#39;s return status is the value of the last (rightmost) command to exit with  a  non-zero
   status, or zero if all commands exit successfully.  If the reserved word !  precedes a pipeline, the exit status of that
   pipeline  is  the  logical  negation  of  the  exit  status as described above.  The shell waits for all commands in the
   pipeline to terminate before returning a value.

   If the time reserved word precedes a pipeline, the elapsed as well as user and system time consumed by its execution are
   reported when the pipeline terminates.  The -p option changes the output format to that specified by  POSIX.   When  the
   shell is in posix mode, it does not recognize time as a reserved word if the next token begins with a `-&#39;.  The TIMEFOR‐
   MAT  variable  may  be set to a format string that specifies how the timing information should be displayed; see the de‐
   scription of TIMEFORMAT under Shell Variables below.

   When the shell is in posix mode, time may be followed by a newline.  In this case, the shell displays the total user and
   system time consumed by the shell and its children.  The TIMEFORMAT variable may be used to specify the  format  of  the
   time information.

   Each  command  in  a  multi-command  pipeline,  where  pipes are created, is executed in a subshell, which is a separate
   process.  See COMMAND EXECUTION ENVIRONMENT for a description of subshells and a subshell environment.  If the  lastpipe
   option  is  enabled  using the shopt builtin (see the description of shopt below), the last element of a pipeline may be
   run by the shell process when job control is not active.
</code></pre>
<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><pre><code>   A list is a sequence of one or more pipelines separated by one of the operators ;, &amp;, &amp;&amp;, or ||, and  optionally  termi‐
   nated by one of ;, &amp;, or &lt;newline&gt;.

   Of these list operators, &amp;&amp; and || have equal precedence, followed by ; and &amp;, which have equal precedence.

   A sequence of one or more newlines may appear in a list instead of a semicolon to delimit commands.

   If  a  command  is terminated by the control operator &amp;, the shell executes the command in the background in a subshell.
   The shell does not wait for the command to finish, and the return status is 0.  These are referred  to  as  asynchronous
   commands.   Commands  separated by a ; are executed sequentially; the shell waits for each command to terminate in turn.
   The return status is the exit status of the last command executed.

   AND and OR lists are sequences of one or more pipelines separated by the &amp;&amp; and || control operators, respectively.  AND
   and OR lists are executed with left associativity.  An AND list has the form

          command1 &amp;&amp; command2

   command2 is executed if, and only if, command1 returns an exit status of zero (success).

   An OR list has the form

          command1 || command2

   command2 is executed if, and only if, command1 returns a non-zero exit status.  The return status of AND and OR lists is
   the exit status of the last command executed in the list.
</code></pre>
<h2 id="Compound-Commands"><a href="#Compound-Commands" class="headerlink" title="Compound Commands"></a>Compound Commands</h2><pre><code>   A compound command is one of the following.  In most cases a list in a command&#39;s description may be separated  from  the
   rest of the command by one or more newlines, and may be followed by a newline in place of a semicolon.

   (list) list  is executed in a subshell (see COMMAND EXECUTION ENVIRONMENT below for a description of a subshell environ‐
          ment).  Variable assignments and builtin commands that affect the shell&#39;s environment do not remain in effect af‐
          ter the command completes.  The return status is the exit status of list.

   &#123; list; &#125;
          list is simply executed in the current shell environment.  list must be terminated with a newline  or  semicolon.
          This  is known as a group command.  The return status is the exit status of list.  Note that unlike the metachar‐
          acters ( and ), &#123; and &#125; are reserved words and must occur where a reserved word is permitted  to  be  recognized.
          Since they do not cause a word break, they must be separated from list by whitespace or another shell metacharac‐
          ter.

   ((expression))
          The  expression is evaluated according to the rules described below under ARITHMETIC EVALUATION.  If the value of
          the expression is non-zero, the return status is 0; otherwise the return status is 1.  The  expression  undergoes
          the same expansions as if it were within double quotes, but double quote characters in expression are not treated
          specially and are removed.

   [[ expression ]]
          Return  a status of 0 or 1 depending on the evaluation of the conditional expression expression.  Expressions are
          composed of the primaries described below under CONDITIONAL EXPRESSIONS.  The words between the [[ and ]] do  not
          undergo word splitting and pathname expansion.  The shell performs tilde expansion, parameter and variable expan‐
          sion, arithmetic expansion, command substitution, process substitution, and quote removal on those words (the ex‐
          pansions that would occur if the words were enclosed in double quotes).  Conditional operators such as -f must be
          unquoted to be recognized as primaries.

          When used with [[, the &lt; and &gt; operators sort lexicographically using the current locale.

   See  the  description  of the test builtin command (section SHELL BUILTIN COMMANDS below) for the handling of parameters
   (i.e.  missing parameters).

   When the == and != operators are used, the string to the right of the operator is considered a pattern and  matched  ac‐
   cording  to the rules described below under Pattern Matching, as if the extglob shell option were enabled.  The = opera‐
   tor is equivalent to ==.  If the nocasematch shell option is enabled, the match is performed without regard to the  case
   of  alphabetic  characters.   The return value is 0 if the string matches (==) or does not match (!=) the pattern, and 1
   otherwise.  Any part of the pattern may be quoted to force the quoted portion to be matched as a string.

   An additional binary operator, =~, is available, with the same precedence as == and !=.  When it is used, the string  to
   the  right  of  the  operator is considered a POSIX extended regular expression and matched accordingly (using the POSIX
   regcomp and regexec interfaces usually described in regex(3)).  The return value is 0 if the string matches the pattern,
   and 1 otherwise.  If the regular expression is syntactically incorrect, the conditional expression&#39;s return value is  2.
   If  the nocasematch shell option is enabled, the match is performed without regard to the case of alphabetic characters.
   If any part of the pattern is quoted, the quoted portion is matched literally.  This means every character in the quoted
   portion matches itself, instead of having any special pattern matching meaning.  If the pattern is  stored  in  a  shell
   variable,  quoting  the variable expansion forces the entire pattern to be matched literally.  Treat bracket expressions
   in regular expressions carefully, since normal quoting and pattern characters lose their meanings between brackets.

   The pattern will match if it matches any part of the string.  Anchor the pattern using the ^ and  $  regular  expression
   operators  to  force  it  to match the entire string.  The array variable BASH_REMATCH records which parts of the string
   matched the pattern.  The element of BASH_REMATCH with index 0 contains the portion of the string  matching  the  entire
   regular  expression.   Substrings matched by parenthesized subexpressions within the regular expression are saved in the
   remaining BASH_REMATCH indices. The element of BASH_REMATCH with index n is the portion of the string matching  the  nth
   parenthesized  subexpression.  Bash sets BASH_REMATCH in the global scope; declaring it as a local variable will lead to
   unexpected results.

   Expressions may be combined using the following operators, listed in decreasing order of precedence:

          ( expression )
                 Returns the value of expression.  This may be used to override the normal precedence of operators.
          ! expression
                 True if expression is false.
          expression1 &amp;&amp; expression2
                 True if both expression1 and expression2 are true.
          expression1 || expression2
                 True if either expression1 or expression2 is true.

          The &amp;&amp; and || operators do not evaluate expression2 if the value of expression1 is sufficient  to  determine  the
          return value of the entire conditional expression.

   for name [ [ in [ word ... ] ] ; ] do list ; done
          The list of words following in is expanded, generating a list of items.  The variable name is set to each element
          of  this  list in turn, and list is executed each time.  If the in word is omitted, the for command executes list
          once for each positional parameter that is set (see PARAMETERS below).  The return status is the exit  status  of
          the last command that executes.  If the expansion of the items following in results in an empty list, no commands
          are executed, and the return status is 0.

   for (( expr1 ; expr2 ; expr3 )) ; do list ; done
          First, the arithmetic expression expr1 is evaluated according to the rules described below under ARITHMETIC EVAL‐
          UATION.   The  arithmetic  expression  expr2  is then evaluated repeatedly until it evaluates to zero.  Each time
          expr2 evaluates to a non-zero value, list is executed and the arithmetic expression expr3 is evaluated.   If  any
          expression  is omitted, it behaves as if it evaluates to 1.  The return value is the exit status of the last com‐
          mand in list that is executed, or false if any of the expressions is invalid.

   select name [ in word ] ; do list ; done
          The list of words following in is expanded, generating a list of items, and the set of expanded words is  printed
          on  the  standard  error,  each  preceded  by a number.  If the in word is omitted, the positional parameters are
          printed (see PARAMETERS below).  select then displays the PS3 prompt and reads a line from  the  standard  input.
          If  the  line  consists of a number corresponding to one of the displayed words, then the value of name is set to
          that word.  If the line is empty, the words and prompt are displayed again.  If EOF is read, the  select  command
          completes  and  returns  1.   Any  other value read causes name to be set to null.  The line read is saved in the
          variable REPLY.  The list is executed after each selection until a break command is executed.  The exit status of
          select is the exit status of the last command executed in list, or zero if no commands were executed.

   case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac
          A case command first expands word, and tries to match it against each pattern in turn, using the  matching  rules
          described  under  Pattern Matching below.  The word is expanded using tilde expansion, parameter and variable ex‐
          pansion, arithmetic expansion, command substitution, process substitution and quote removal.  Each pattern  exam‐
          ined is expanded using tilde expansion, parameter and variable expansion, arithmetic expansion, command substitu‐
          tion,  process  substitution,  and  quote removal.  If the nocasematch shell option is enabled, the match is per‐
          formed without regard to the case of alphabetic characters.  When a match is found, the corresponding list is ex‐
          ecuted.  If the ;; operator is used, no subsequent matches are attempted after the first pattern match.  Using ;&amp;
          in place of ;; causes execution to continue with the list associated with the next set of patterns.  Using ;;&amp; in
          place of ;; causes the shell to test the next pattern list in the statement, if any, and execute  any  associated
          list  on a successful match, continuing the case statement execution as if the pattern list had not matched.  The
          exit status is zero if no pattern matches.  Otherwise, it is the exit status of  the  last  command  executed  in
          list.

   if list; then list; [ elif list; then list; ] ... [ else list; ] fi
          The  if  list  is executed.  If its exit status is zero, the then list is executed.  Otherwise, each elif list is
          executed in turn, and if its exit status is zero, the corresponding then list is executed and  the  command  com‐
          pletes.   Otherwise,  the else list is executed, if present.  The exit status is the exit status of the last com‐
          mand executed, or zero if no condition tested true.

   while list-1; do list-2; done
   until list-1; do list-2; done
          The while command continuously executes the list list-2 as long as the last command in the list list-1 returns an
          exit status of zero.  The until command is identical to the while command,  except  that  the  test  is  negated:
          list-2  is executed as long as the last command in list-1 returns a non-zero exit status.  The exit status of the
          while and until commands is the exit status of the last command executed in list-2, or zero if none was executed.
</code></pre>
<h2 id="Coprocesses"><a href="#Coprocesses" class="headerlink" title="Coprocesses"></a>Coprocesses</h2><pre><code>   A coprocess is a shell command preceded by the coproc reserved word.  A coprocess is executed asynchronously in  a  sub‐
   shell,  as  if  the command had been terminated with the &amp; control operator, with a two-way pipe established between the
   executing shell and the coprocess.

   The syntax for a coprocess is:

          coproc [NAME] command [redirections]

   This creates a coprocess named NAME.  command may be either a simple command or a compound command (see above).  NAME is
   a shell variable name.  If NAME is not supplied, the default name is COPROC.

   The recommended form to use for a coprocess is

          coproc NAME &#123; command [redirections]; &#125;

   This form is recommended because simple commands result in the coprocess always being named COPROC, and it is simpler to
   use and more complete than the other compound commands.

   If command is a compound command, NAME is optional. The word following coproc determines whether  that  word  is  inter‐
   preted  as  a  variable name: it is interpreted as NAME if it is not a reserved word that introduces a compound command.
   If command is a simple command, NAME is not allowed; this is to avoid confusion between NAME and the first word  of  the
   simple command.

   When  the coprocess is executed, the shell creates an array variable (see Arrays below) named NAME in the context of the
   executing shell.  The standard output of command is connected via a pipe to a file descriptor in  the  executing  shell,
   and  that  file  descriptor is assigned to NAME[0].  The standard input of command is connected via a pipe to a file de‐
   scriptor in the executing shell, and that file descriptor is assigned to NAME[1].  This pipe is established  before  any
   redirections  specified  by  the  command (see REDIRECTION below).  The file descriptors can be utilized as arguments to
   shell commands and redirections using standard word expansions.  Other than those created to execute command and process
   substitutions, the file descriptors are not available in subshells.

   The process ID of the shell spawned to execute the coprocess is available as the value of the  variable  NAME_PID.   The
   wait builtin command may be used to wait for the coprocess to terminate.

   Since the coprocess is created as an asynchronous command, the coproc command always returns success.  The return status
   of a coprocess is the exit status of command.
</code></pre>
<h2 id="Shell-Function-Definitions"><a href="#Shell-Function-Definitions" class="headerlink" title="Shell Function Definitions"></a>Shell Function Definitions</h2><pre><code>   A shell function is an object that is called like a simple command and executes a compound command with a new set of po‐
   sitional parameters.  Shell functions are declared as follows:

   fname () compound-command [redirection]
   function fname [()] compound-command [redirection]
          This  defines  a function named fname.  The reserved word function is optional.  If the function reserved word is
          supplied, the parentheses are optional.  The body of the function is the compound command  compound-command  (see
          Compound  Commands  above).   That  command is usually a list of commands between &#123; and &#125;, but may be any command
          listed under Compound Commands above.  If the function reserved word is used, but the parentheses  are  not  sup‐
          plied,  the  braces  are  recommended.  compound-command is executed whenever fname is specified as the name of a
          simple command.  When in posix mode, fname must be a valid shell name and may not be the name of one of the POSIX
          special builtins.  In default mode, a function name can be any unquoted shell word that does not contain $.   Any
          redirections (see REDIRECTION below) specified when a function is defined are performed when the function is exe‐
          cuted.  The exit status of a function definition is zero unless a syntax error occurs or a readonly function with
          the  same  name already exists.  When executed, the exit status of a function is the exit status of the last com‐
          mand executed in the body.  (See FUNCTIONS below.)
</code></pre>
<h1 id="COMMENTS"><a href="#COMMENTS" class="headerlink" title="COMMENTS"></a>COMMENTS</h1><pre><code>   In a non-interactive shell, or an interactive shell in which the interactive_comments option to the shopt builtin is en‐
   abled (see SHELL BUILTIN COMMANDS below), a word beginning with # causes that word and all remaining characters on  that
   line  to be ignored.  An interactive shell without the interactive_comments option enabled does not allow comments.  The
   interactive_comments option is on by default in interactive shells.
</code></pre>
<h1 id="QUOTING"><a href="#QUOTING" class="headerlink" title="QUOTING"></a>QUOTING</h1><pre><code>   Quoting is used to remove the special meaning of certain characters or words to the shell.  Quoting can be used to  dis‐
   able  special  treatment for special characters, to prevent reserved words from being recognized as such, and to prevent
   parameter expansion.

   Each of the metacharacters listed above under DEFINITIONS has special meaning to the shell and must be quoted if  it  is
   to represent itself.

   When  the command history expansion facilities are being used (see HISTORY EXPANSION below), the history expansion char‐
   acter, usually !, must be quoted to prevent history expansion.

   There are three quoting mechanisms: the escape character, single quotes, and double quotes.

   A non-quoted backslash (\) is the escape character.  It preserves the literal value of the next character that  follows,
   with  the  exception of &lt;newline&gt;.  If a \&lt;newline&gt; pair appears, and the backslash is not itself quoted, the \&lt;newline&gt;
   is treated as a line continuation (that is, it is removed from the input stream and effectively ignored).

   Enclosing characters in single quotes preserves the literal value of each character within the quotes.  A  single  quote
   may not occur between single quotes, even when preceded by a backslash.

   Enclosing  characters  in double quotes preserves the literal value of all characters within the quotes, with the excep‐
   tion of $, `, \, and, when history expansion is enabled, !.  When the shell is in posix mode, the ! has no special mean‐
   ing within double quotes, even when history expansion is enabled.  The characters $ and ` retain their  special  meaning
   within  double quotes.  The backslash retains its special meaning only when followed by one of the following characters:
   $, `, &quot;, \, or &lt;newline&gt;.  A double quote may be quoted within double quotes by preceding it with a backslash.   If  en‐
   abled,  history  expansion  will be performed unless an !  appearing in double quotes is escaped using a backslash.  The
   backslash preceding the !  is not removed.

   The special parameters * and @ have special meaning when in double quotes (see PARAMETERS below).

   Character sequences of the form $&#39;string&#39; are treated as a special variant of single quotes.  The  sequence  expands  to
   string,  with backslash-escaped characters in string replaced as specified by the ANSI C standard.  Backslash escape se‐
   quences, if present, are decoded as follows:
          \a     alert (bell)
          \b     backspace
          \e
          \E     an escape character
          \f     form feed
          \n     new line
          \r     carriage return
          \t     horizontal tab
          \v     vertical tab
          \\     backslash
          \&#39;     single quote
          \&quot;     double quote
          \?     question mark
          \nnn   the eight-bit character whose value is the octal value nnn (one to three octal digits)
          \xHH   the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
          \uHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
          \UHHHHHHHH
                 the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex dig‐
                 its)
          \cx    a control-x character

   The expanded result is single-quoted, as if the dollar sign had not been present.

   A double-quoted string preceded by a dollar sign ($&quot;string&quot;) will cause the string to be  translated  according  to  the
   current  locale.   The gettext infrastructure performs the lookup and translation, using the LC_MESSAGES, TEXTDOMAINDIR,
   and TEXTDOMAIN shell variables.  If the current locale is C or POSIX, if there are no translations available, or if  the
   string  is  not translated, the dollar sign is ignored.  This is a form of double quoting, so the string remains double-
   quoted by default, whether or not it is translated and replaced.  If the noexpand_translation option  is  enabled  using
   the  shopt  builtin,  translated strings are single-quoted instead of double-quoted.  See the description of shopt below
   under SHELLBUILTINCOMMANDS.
</code></pre>
<h1 id="PARAMETERS"><a href="#PARAMETERS" class="headerlink" title="PARAMETERS"></a>PARAMETERS</h1><pre><code>   A parameter is an entity that stores values.  It can be a name, a number, or one of the special characters listed  below
   under Special Parameters.  A variable is a parameter denoted by a name.  A variable has a value and zero or more attrib‐
   utes.  Attributes are assigned using the declare builtin command (see declare below in SHELL BUILTIN COMMANDS).

   A  parameter  is set if it has been assigned a value.  The null string is a valid value.  Once a variable is set, it may
   be unset only by using the unset builtin command (see SHELL BUILTIN COMMANDS below).

   A variable may be assigned to by a statement of the form

          name=[value]

   If value is not given, the variable is assigned the null string.  All values  undergo  tilde  expansion,  parameter  and
   variable  expansion,  command substitution, arithmetic expansion, and quote removal (see EXPANSION below).  If the vari‐
   able has its integer attribute set, then value is evaluated as an arithmetic expression even if the  $((...))  expansion
   is  not  used  (see  Arithmetic  Expansion below).  Word splitting and pathname expansion are not performed.  Assignment
   statements may also appear as arguments to the alias, declare, typeset, export, readonly,  and  local  builtin  commands
   (declaration  commands).   When in posix mode, these builtins may appear in a command after one or more instances of the
   command builtin and retain these assignment statement properties.

   In the context where an assignment statement is assigning a value to a shell variable or array index,  the  +=  operator
   can  be  used to append to or add to the variable&#39;s previous value.  This includes arguments to builtin commands such as
   declare that accept assignment statements (declaration commands).  When += is applied to a variable for which the  inte‐
   ger  attribute  has  been set, value is evaluated as an arithmetic expression and added to the variable&#39;s current value,
   which is also evaluated.  When += is applied to an array variable using compound  assignment  (see  Arrays  below),  the
   variable&#39;s value is not unset (as it is when using =), and new values are appended to the array beginning at one greater
   than  the  array&#39;s  maximum  index  (for indexed arrays) or added as additional key-value pairs in an associative array.
   When applied to a string-valued variable, value is expanded and appended to the variable&#39;s value.

   A variable can be assigned the nameref attribute using the -n option to the declare or local builtin commands  (see  the
   descriptions of declare and local below) to create a nameref, or a reference to another variable.  This allows variables
   to  be  manipulated  indirectly.  Whenever the nameref variable is referenced, assigned to, unset, or has its attributes
   modified (other than using or changing the nameref attribute itself), the operation is actually performed on  the  vari‐
   able  specified  by the nameref variable&#39;s value.  A nameref is commonly used within shell functions to refer to a vari‐
   able whose name is passed as an argument to the function.  For instance, if a variable name is passed to a  shell  func‐
   tion as its first argument, running
          declare -n ref=$1
   inside  the function creates a nameref variable ref whose value is the variable name passed as the first argument.  Ref‐
   erences and assignments to ref, and changes to its attributes, are treated as  references,  assignments,  and  attribute
   modifications  to  the  variable whose name was passed as $1.  If the control variable in a for loop has the nameref at‐
   tribute, the list of words can be a list of shell variables, and a name reference will be established for each  word  in
   the  list, in turn, when the loop is executed.  Array variables cannot be given the nameref attribute.  However, nameref
   variables can reference array variables and subscripted array variables.  Namerefs can be unset using the -n  option  to
   the  unset  builtin.   Otherwise,  if unset is executed with the name of a nameref variable as an argument, the variable
   referenced by the nameref variable will be unset.
</code></pre>
<h2 id="Positional-Parameters"><a href="#Positional-Parameters" class="headerlink" title="Positional Parameters"></a>Positional Parameters</h2><pre><code>   A positional parameter is a parameter denoted by one or more digits, other than the single digit 0.  Positional  parame‐
   ters  are  assigned  from the shell&#39;s arguments when it is invoked, and may be reassigned using the set builtin command.
   Positional parameters may not be assigned to with assignment statements.  The positional parameters are temporarily  re‐
   placed when a shell function is executed (see FUNCTIONS below).

   When  a  positional parameter consisting of more than a single digit is expanded, it must be enclosed in braces (see EX‐
   PANSION below).
</code></pre>
<h2 id="Special-Parameters"><a href="#Special-Parameters" class="headerlink" title="Special Parameters"></a>Special Parameters</h2><pre><code>   The shell treats several parameters specially.  These parameters may only be referenced; assignment to them is  not  al‐
   lowed.
   *      Expands  to  the  positional parameters, starting from one.  When the expansion is not within double quotes, each
          positional parameter expands to a separate word.  In contexts where it is performed, those words are  subject  to
          further  word  splitting and pathname expansion.  When the expansion occurs within double quotes, it expands to a
          single word with the value of each parameter separated by the first character of the IFS special variable.   That
          is,  &quot;$*&quot;  is equivalent to &quot;$1c$2c...&quot;, where c is the first character of the value of the IFS variable.  If IFS
          is unset, the parameters are separated by spaces.  If IFS is null, the parameters are joined without  intervening
          separators.
   @      Expands to the positional parameters, starting from one.  In contexts where word splitting is performed, this ex‐
          pands  each positional parameter to a separate word; if not within double quotes, these words are subject to word
          splitting.  In contexts where word splitting is not performed, this expands to a single word with each positional
          parameter separated by a space.  When the expansion occurs within double quotes, each parameter expands to a sep‐
          arate word.  That is, &quot;$@&quot; is equivalent to &quot;$1&quot; &quot;$2&quot; ...  If the double-quoted expansion occurs within  a  word,
          the expansion of the first parameter is joined with the beginning part of the original word, and the expansion of
          the  last  parameter is joined with the last part of the original word.  When there are no positional parameters,
          &quot;$@&quot; and $@ expand to nothing (i.e., they are removed).
   #      Expands to the number of positional parameters in decimal.
   ?      Expands to the exit status of the most recently executed foreground pipeline.
   -      Expands to the current option flags as specified upon invocation, by the set builtin command, or those set by the
          shell itself (such as the -i option).
   $      Expands to the process ID of the shell. In a subshell, it expands to the process ID of the current shell, not the
          subshell.
   !      Expands to the process ID of the job most recently placed into the background, whether executed as  an  asynchro‐
          nous command or using the bg builtin (see JOB CONTROL below).
   0      Expands  to the name of the shell or shell script.  This is set at shell initialization.  If bash is invoked with
          a file of commands, $0 is set to the name of that file.  If bash is started with the -c option, then $0 is set to
          the first argument after the string to be executed, if one is present.  Otherwise, it is set to the filename used
          to invoke bash, as given by argument zero.
</code></pre>
<h2 id="Shell-Variables"><a href="#Shell-Variables" class="headerlink" title="Shell Variables"></a>Shell Variables</h2><pre><code>   The following variables are set by the shell:

   _      At shell startup, set to the pathname used to invoke the shell or shell script being executed as  passed  in  the
          environment or argument list.  Subsequently, expands to the last argument to the previous simple command executed
          in  the  foreground,  after  expansion.   Also  set to the full pathname used to invoke each command executed and
          placed in the environment exported to that command.  When checking mail, this parameter holds  the  name  of  the
          mail file currently being checked.
   BASH   Expands to the full filename used to invoke this instance of bash.
   BASHOPTS
          A  colon-separated list of enabled shell options.  Each word in the list is a valid argument for the -s option to
          the shopt builtin command (see SHELL BUILTIN COMMANDS below).  The options appearing in BASHOPTS  are  those  re‐
          ported as on by shopt.  If this variable is in the environment when bash starts up, each shell option in the list
          will be enabled before reading any startup files.  This variable is read-only.
   BASHPID
          Expands to the process ID of the current bash process.  This differs from $$ under certain circumstances, such as
          subshells  that  do not require bash to be re-initialized.  Assignments to BASHPID have no effect.  If BASHPID is
          unset, it loses its special properties, even if it is subsequently reset.
   BASH_ALIASES
          An associative array variable whose members correspond to the internal list of aliases as maintained by the alias
          builtin.  Elements added to this array appear in the alias list; however, unsetting array elements currently does
          not cause aliases to be removed from the alias list.  If BASH_ALIASES is unset, it loses its special  properties,
          even if it is subsequently reset.
   BASH_ARGC
          An  array  variable  whose  values  are the number of parameters in each frame of the current bash execution call
          stack.  The number of parameters to the current subroutine (shell function or script executed with .  or  source)
          is  at  the  top  of  the  stack.   When a subroutine is executed, the number of parameters passed is pushed onto
          BASH_ARGC.  The shell sets BASH_ARGC only when in extended debugging mode (see the description  of  the  extdebug
          option  to the shopt builtin below).  Setting extdebug after the shell has started to execute a script, or refer‐
          encing this variable when extdebug is not set, may result in inconsistent values.
   BASH_ARGV
          An array variable containing all of the parameters in the current bash execution call stack.  The final parameter
          of the last subroutine call is at the top of the stack; the first parameter of the initial call is at the bottom.
          When a subroutine is executed, the parameters supplied are pushed onto BASH_ARGV.  The shell sets BASH_ARGV  only
          when in extended debugging mode (see the description of the extdebug option to the shopt builtin below).  Setting
          extdebug  after the shell has started to execute a script, or referencing this variable when extdebug is not set,
          may result in inconsistent values.
   BASH_ARGV0
          When referenced, this variable expands to the name of the shell or shell script (identical to  $0;  see  the  de‐
          scription  of special parameter 0 above).  Assignment to BASH_ARGV0 causes the value assigned to also be assigned
          to $0.  If BASH_ARGV0 is unset, it loses its special properties, even if it is subsequently reset.
   BASH_CMDS
          An associative array variable whose members correspond to the internal hash table of commands  as  maintained  by
          the  hash builtin.  Elements added to this array appear in the hash table; however, unsetting array elements cur‐
          rently does not cause command names to be removed from the hash table.  If BASH_CMDS is unset, it loses its  spe‐
          cial properties, even if it is subsequently reset.
   BASH_COMMAND
          The  command currently being executed or about to be executed, unless the shell is executing a command as the re‐
          sult of a trap, in which case it is the command executing at the time of the trap.  If BASH_COMMAND is unset,  it
          loses its special properties, even if it is subsequently reset.
   BASH_EXECUTION_STRING
          The command argument to the -c invocation option.
   BASH_LINENO
          An  array variable whose members are the line numbers in source files where each corresponding member of FUNCNAME
          was invoked.  $&#123;BASH_LINENO[$i]&#125; is the line number in  the  source  file  ($&#123;BASH_SOURCE[$i+1]&#125;)  where  $&#123;FUNC‐
          NAME[$i]&#125; was called (or $&#123;BASH_LINENO[$i-1]&#125; if referenced within another shell function).  Use LINENO to obtain
          the current line number.
   BASH_LOADABLES_PATH
          A colon-separated list of directories in which the shell looks for dynamically loadable builtins specified by the
          enable command.
   BASH_REMATCH
          An  array  variable whose members are assigned by the =~ binary operator to the [[ conditional command.  The ele‐
          ment with index 0 is the portion of the string matching the entire regular expression.  The element with index  n
          is the portion of the string matching the nth parenthesized subexpression.
   BASH_SOURCE
          An  array  variable  whose  members  are the source filenames where the corresponding shell function names in the
          FUNCNAME  array  variable  are  defined.   The  shell  function  $&#123;FUNCNAME[$i]&#125;   is   defined   in   the   file
          $&#123;BASH_SOURCE[$i]&#125; and called from $&#123;BASH_SOURCE[$i+1]&#125;.
   BASH_SUBSHELL
          Incremented  by one within each subshell or subshell environment when the shell begins executing in that environ‐
          ment.  The initial value is 0.  If BASH_SUBSHELL is unset, it loses its special properties, even if it is  subse‐
          quently reset.
   BASH_VERSINFO
          A  readonly array variable whose members hold version information for this instance of bash.  The values assigned
          to the array members are as follows:
          BASH_VERSINFO[0]        The major version number (the release).
          BASH_VERSINFO[1]        The minor version number (the version).
          BASH_VERSINFO[2]        The patch level.
          BASH_VERSINFO[3]        The build version.
          BASH_VERSINFO[4]        The release status (e.g., beta1).
          BASH_VERSINFO[5]        The value of MACHTYPE.
   BASH_VERSION
          Expands to a string describing the version of this instance of bash.
   COMP_CWORD
          An index into $&#123;COMP_WORDS&#125; of the word containing the current cursor position.  This variable is available  only
          in shell functions invoked by the programmable completion facilities (see Programmable Completion below).
   COMP_KEY
          The key (or final key of a key sequence) used to invoke the current completion function.
   COMP_LINE
          The  current  command  line.  This variable is available only in shell functions and external commands invoked by
          the programmable completion facilities (see Programmable Completion below).
   COMP_POINT
          The index of the current cursor position relative to the beginning of the current command.  If the current cursor
          position is at the end of the current command, the value of this variable is equal to $
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://illyber.github.io">illyber</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://illyber.github.io/2023/11/21/Shell/man_bash/">https://illyber.github.io/2023/11/21/Shell/man_bash/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://illyber.github.io" target="_blank">MyBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://illyber-images.oss-cn-chengdu.aliyuncs.com/kuroyukihime-3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/21/Shell/bash_&amp;_zsh/" title="bash 快捷键和配置文件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">bash 快捷键和配置文件</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/21/Language/C/type_qualifier/" title="ANSI C 类型限定符"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ANSI C 类型限定符</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/kuroyukihime-3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">illyber</div><div class="author-info__description">学习计算机的记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#BASH-1-General-Commands-Manual-BASH-1"><span class="toc-number">1.</span> <span class="toc-text">BASH(1)                     General Commands Manual                           BASH(1)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DESCRIPTION"><span class="toc-number">2.</span> <span class="toc-text">DESCRIPTION</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OPTIONS"><span class="toc-number">3.</span> <span class="toc-text">OPTIONS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARGUMENTS"><span class="toc-number">4.</span> <span class="toc-text">ARGUMENTS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#INVOCATION"><span class="toc-number">5.</span> <span class="toc-text">INVOCATION</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DEFINITIONS"><span class="toc-number">6.</span> <span class="toc-text">DEFINITIONS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RESERVED-WORDS"><span class="toc-number">7.</span> <span class="toc-text">RESERVED WORDS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SHELL-GRAMMAR"><span class="toc-number">8.</span> <span class="toc-text">SHELL GRAMMAR</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Simple-Commands"><span class="toc-number">8.1.</span> <span class="toc-text">Simple Commands</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipelines"><span class="toc-number">8.2.</span> <span class="toc-text">Pipelines</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lists"><span class="toc-number">8.3.</span> <span class="toc-text">Lists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Compound-Commands"><span class="toc-number">8.4.</span> <span class="toc-text">Compound Commands</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Coprocesses"><span class="toc-number">8.5.</span> <span class="toc-text">Coprocesses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-Function-Definitions"><span class="toc-number">8.6.</span> <span class="toc-text">Shell Function Definitions</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#COMMENTS"><span class="toc-number">9.</span> <span class="toc-text">COMMENTS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QUOTING"><span class="toc-number">10.</span> <span class="toc-text">QUOTING</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PARAMETERS"><span class="toc-number">11.</span> <span class="toc-text">PARAMETERS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Positional-Parameters"><span class="toc-number">11.1.</span> <span class="toc-text">Positional Parameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Special-Parameters"><span class="toc-number">11.2.</span> <span class="toc-text">Special Parameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-Variables"><span class="toc-number">11.3.</span> <span class="toc-text">Shell Variables</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/21/punctuation/" title="标点符号的英文名称">标点符号的英文名称</a><time datetime="2023-11-21T15:22:21.957Z" title="发表于 2023-11-21 23:22:21">2023-11-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/21/network/" title="网络是怎样连接的_户根勤-笔记">网络是怎样连接的_户根勤-笔记</a><time datetime="2023-11-21T15:22:21.954Z" title="发表于 2023-11-21 23:22:21">2023-11-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/21/Shell/shell_scripting/" title="Shell-脚本编程">Shell-脚本编程</a><time datetime="2023-11-21T15:22:21.954Z" title="发表于 2023-11-21 23:22:21">2023-11-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/21/Shell/wildcard_&amp;_regex/" title="Shell-通配符和正则表达式">Shell-通配符和正则表达式</a><time datetime="2023-11-21T15:22:21.954Z" title="发表于 2023-11-21 23:22:21">2023-11-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/21/Tool/docker/" title="docker 常用命令">docker 常用命令</a><time datetime="2023-11-21T15:22:21.954Z" title="发表于 2023-11-21 23:22:21">2023-11-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By illyber</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><div class="js-pjax"><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'illyber/comments')
  ele.setAttribute('issue-term', 'url')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme (theme) {
  const iframe = document.querySelector('.utterances-frame')
  if (iframe) {
    const theme = theme === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

btf.addModeChange('utterances', utterancesTheme)

if ('Utterances' === 'Utterances' || !true) {
  if (true) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>