<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C notes | MyBlog</title><meta name="author" content="illyber"><meta name="copyright" content="illyber"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C version K&amp;R C。1978年由 Kernighan 和Ritchie合写的书《The C Programming Language》，形成了C语言的事实的标准，简称为K&amp;R C。 ANSI C（C89或C90）。1989年，美国国家标准局（ANSI）颁布了第一个官方的C语言标准（X3.159-1989），简称为ANSI C或C89；1990年，它被国际标准化组织（IS">
<meta property="og:type" content="article">
<meta property="og:title" content="C notes">
<meta property="og:url" content="http://example.com/2023/01/28/c-notes/index.html">
<meta property="og:site_name" content="MyBlog">
<meta property="og:description" content="C version K&amp;R C。1978年由 Kernighan 和Ritchie合写的书《The C Programming Language》，形成了C语言的事实的标准，简称为K&amp;R C。 ANSI C（C89或C90）。1989年，美国国家标准局（ANSI）颁布了第一个官方的C语言标准（X3.159-1989），简称为ANSI C或C89；1990年，它被国际标准化组织（IS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-01-28T11:55:00.000Z">
<meta property="article:modified_time" content="2023-06-19T04:34:35.836Z">
<meta property="article:author" content="illyber">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/28/c-notes/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-19 12:34:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="MyBlog"><span class="site-name">MyBlog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-28T11:55:00.000Z" title="发表于 2023-01-28 19:55:00">2023-01-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-19T04:34:35.836Z" title="更新于 2023-06-19 12:34:35">2023-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/language/">language</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/language/C/">C</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C notes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-version"><a href="#C-version" class="headerlink" title="C version"></a>C version</h1><ul>
<li>K&amp;R C。1978年由 Kernighan 和Ritchie合写的书《The C Programming Language》，形成了C语言的事实的标准，简称为K&amp;R C。</li>
<li>ANSI C（C89或C90）。1989年，美国国家标准局（ANSI）颁布了第一个官方的C语言标准（X3.159-1989），简称为ANSI C或C89；1990年，它被国际标准化组织（ISO）采纳国际标准（ISO&#x2F;IEC9899:1990），简称为C90。这个标准是目前广泛使用并完全支持的。</li>
<li>C99。1999年，ANSI&#x2F;ISO联合委员会又推出了新的标准（ISO9899:1999），简称C99。这个标准目前支持的可能还不太全面。</li>
<li>C11。2011年正式发布了 ISO&#x2F;IEC 9899:2011，简称为 C11 标准。</li>
<li>C17（也被称为为 C18）是于2018年6月发布的 ISO&#x2F;IEC 9899:2018 的非正式名称，也是目前（截止到2020年6月）为止最新的 C语言编程标准，被用来替代 C11 标准。</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="大小一览"><a href="#大小一览" class="headerlink" title="大小一览"></a>大小一览</h2><p>一字节的定义是char类型的位</p>
<table>
<thead>
<tr>
<th></th>
<th>char</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>long long</th>
</tr>
</thead>
<tbody><tr>
<td>字节（byte）</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>float</td>
<td>double</td>
<td>long double</td>
</tr>
<tr>
<td>字节（byte）</td>
<td></td>
<td></td>
<td>4</td>
<td>8</td>
<td>16</td>
</tr>
</tbody></table>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>0开头是八进制，0x开头是16进制。</p>
<h3 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a>_Bool类型</h3><p>_Bool 的大小由编译器决定；</p>
<p>stdbool.h 头文件 定义 bool 为 _Bool 的别名，定义了值为1和0的符号变量true, false.</p>
<h3 id="size-t-size-type"><a href="#size-t-size-type" class="headerlink" title="size_t (size type)"></a>size_t (size type)</h3><p>size_t 的大小由具体的计算机决定，方便移植；</p>
<p>debian&#x2F;ASUS u4000u 的大小为 8 字节；SIZE_MAX 是 size_t 的最大值，当前定义在 stdint.h</p>
<h3 id="time-t"><a href="#time-t" class="headerlink" title="time_t"></a>time_t</h3><p>time_t 格式转换符是</p>
<p>善用 const 关键字</p>
<h2 id="字符-x2F-字符变量"><a href="#字符-x2F-字符变量" class="headerlink" title="字符&#x2F;字符变量"></a>字符&#x2F;字符变量</h2><p><strong>转义序列</strong></p>
<ul>
<li>转义字符：C语言中，转义字符是斜杠<code>\</code>；能将转义字符和后面的东西替换成其它字符</li>
<li>转义序列（escape sequence）：如<code>\n</code>，8进制转义序列<code>\101</code>，16进制转义序列<code>\x41</code>；是转义字符和后面的字符组成的序列</li>
<li>控制字符：用于「控制」的字符。</li>
<li>非打印字符：无法显示出来的字符</li>
</ul>
<p><strong>diff:</strong>  </p>
<ol>
<li>转义字符只有一个字符，转义序列是多个字符组成的序列。  </li>
<li>非打印字符包含控制字符  </li>
<li>换行符LF的转义序列是<code>\n</code></li>
</ol>
<p><strong>CTRL+字母：</strong></p>
<ol>
<li>ASCII码1，2，3…分别依次对应键盘按键的<code>Ctrl+A</code>键，<code>Ctrl+B</code>键，<code>Ctrl+C</code>键，…<code>Ctrl+Z</code>键的ASCII为26.  </li>
<li>参考大写字母后的编码，按键<code>Ctrl+[</code>键产生ASCII码27，<code>Ctrl+\</code>键产生ASCII码28，<code>Ctrl+]</code>键产生ASCII码29，<code>Ctrl+^</code>键产生ASCII码30。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://tangyilong.com/2019/04/13/%E5%AD%97%E6%AF%8D%E5%AF%B9%E5%BA%94%E7%9A%84ASCII%E7%A0%81%E5%92%8CCTRL%E5%8A%A0%E5%AD%97%E6%AF%8D%E7%9A%84/">键盘各键对应的编码值（key code）</a></p>
<h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527060.png" alt="image-20220430225753570"></p>
<p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527061.png" alt="image-20220430225821521"></p>
<p>11.9 字符串数字转数值数字的函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>atoi()</td>
<td>字符串数字转数值数字</td>
<td>atoi(“42regular”)将返回整数42</td>
</tr>
<tr>
<td>atol()</td>
<td>把字符串转换成long类型的值</td>
<td></td>
</tr>
<tr>
<td>atof()</td>
<td>把字符串转换成 double 类型的值</td>
<td></td>
</tr>
<tr>
<td>strtol()</td>
<td>把字符串转换成long类型的值，可以指定数字的进制</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>(char *nptr, char **endptr, int base)</code></td>
<td></td>
</tr>
<tr>
<td>strtoul()</td>
<td>把字符串转换成unsigned long类型的值，可以指定数字的进制</td>
<td></td>
</tr>
<tr>
<td>strtod()</td>
<td>把字符串转换成double类型的值</td>
<td></td>
</tr>
</tbody></table>
<h2 id="字符串-x2F-字符数组"><a href="#字符串-x2F-字符数组" class="headerlink" title="字符串&#x2F;字符数组"></a>字符串&#x2F;字符数组</h2><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="字符串列表"><a href="#字符串列表" class="headerlink" title="字符串列表"></a>字符串列表</h3><p>strtol()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">//参数为地址，返回字符串长度</span></span><br><span class="line"><span class="comment">//返回字符串的长度，不包括空字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>( <span class="type">char</span> *target, <span class="type">const</span> *source);</span><br><span class="line"><span class="built_in">strncat</span>( <span class="type">char</span> *dest, <span class="type">const</span> *source, <span class="type">int</span> *n);</span><br><span class="line"><span class="comment">//string concatenation，拼接字符串</span></span><br><span class="line"><span class="comment">//n dest的可用空间；</span></span><br><span class="line"><span class="comment">//参数为两个字符串地址，返回前一个字符串地址。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcmp</span>( <span class="type">char</span> *, <span class="type">char</span> *);</span><br><span class="line"><span class="comment">//返回值：前减后决定正负</span></span><br><span class="line"><span class="comment">//strcmp(&quot;A&quot;, &quot;A&quot;) is 0</span></span><br><span class="line"><span class="comment">//strcmp(&quot;A&quot;, &quot;B&quot;) is -1</span></span><br><span class="line"><span class="comment">//strcmp(&quot;B&quot;, &quot;A&quot;) is 1</span></span><br><span class="line"><span class="comment">//strcmp(&quot;C&quot;, &quot;A&quot;) is 1</span></span><br><span class="line"><span class="comment">//strcmp(&quot;Z&quot;, &quot;a&quot;) is -1</span></span><br><span class="line"><span class="comment">//strcmp(&quot;apples&quot;, &quot;apple&quot;) is 1</span></span><br><span class="line"><span class="built_in">strncmp</span>( <span class="type">char</span> *arg1, <span class="type">char</span> *arg2, <span class="type">int</span> n);</span><br><span class="line"><span class="comment">//比较字符串的前 n 个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">( <span class="type">char</span> *<span class="keyword">restrict</span> target, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> source )</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">( <span class="type">char</span> *<span class="keyword">restrict</span> target, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> source, <span class="type">size_t</span> count )</span>;</span><br><span class="line"><span class="comment">//n 是要拷贝的字符数，strncpy() 不会自动加空字符。想想为什么不加空字符？</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s, <span class="type">int</span> c)</span>;</span><br><span class="line"><span class="comment">//如果s字符串中包含c字符，该函数返回指向s字符串首位置的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；</span></span><br><span class="line"><span class="comment">//如果在字符串s中未找到c字符，该函数则返回空指针。</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s1, <span class="type">const</span> <span class="type">char</span> * s2)</span>;</span><br><span class="line"><span class="comment">//该函数返回指向 s1 字符串中 s2 字符串出现的首位置。如果在 s1 中没有找到 s2，则返回空指针。</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">sprintf</span>( <span class="type">char</span> * target, 格式化字符串, 待输入项列表);</span><br><span class="line"><span class="comment">//和printf() 相似，但是sprintf() 的目的地是 target指向的数据对象。</span></span><br><span class="line"><span class="comment">//联想：printf/fprintf。sprintf() 函数原型位于 stdio.h 头文件中。</span></span><br></pre></td></tr></table></figure>

<h3 id="把字符串转换为数字-P313"><a href="#把字符串转换为数字-P313" class="headerlink" title="把字符串转换为数字 P313"></a>把字符串转换为数字 P313</h3><table>
<thead>
<tr>
<th>函数原型位于stdlib.h</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>atoi( char *);</code></td>
<td>以字符串地址为参数，到’\0’或非数字字符时停止；<br />返回数字字符串对应的 int. 即把 “100” 转换成 100，只有非数字字符时转换成0. 肯定是字符串啊，2 位及以上数会是字符串。</td>
</tr>
<tr>
<td>atof(); atol();</td>
<td></td>
</tr>
<tr>
<td>strtol(const char * restrict nptr, char ** restrict endptr, int base)</td>
<td>nptr 是待转换的字符串的地址，endptr 指向结束位置后一个的地址，base 是写入的地址。函数返回 long</td>
</tr>
<tr>
<td>strtoul()</td>
<td></td>
</tr>
<tr>
<td>strtod()</td>
<td>只转换成十进制，所以只要两个参数</td>
</tr>
</tbody></table>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>在K&amp;R C中，表达式或参数中的float类型值会被自动转换成double类型。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数字数组初始化"><a href="#数字数组初始化" class="headerlink" title="数字数组初始化"></a>数字数组初始化</h3><p>未被初始化的数组元素置为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的语法</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">212</span>&#125;;<span class="comment">//数值数组</span></span><br><span class="line"><span class="type">char</span> ch[<span class="number">100</span>]=&#123;<span class="string">&quot;hello&quot;</span>&#125;;<span class="comment">//字符数组初始化</span></span><br><span class="line"><span class="type">char</span> ch[<span class="number">100</span>]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> ch[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始化器</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">6</span>] = &#123;[<span class="number">5</span>] = <span class="number">212</span>&#125;;<span class="comment">// 把arr[5]初始化为212</span></span><br><span class="line"><span class="type">int</span> staff[] = &#123;<span class="number">1</span>, [<span class="number">6</span>] = <span class="number">4</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="字符数组初始化"><a href="#字符数组初始化" class="headerlink" title="字符数组初始化"></a>字符数组初始化</h3><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组是一维数组的嵌套</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="英语读法"><a href="#英语读法" class="headerlink" title="英语读法"></a>英语读法</h3><ul>
<li>*x 读作: pointed by x （由x指向的）</li>
<li>&amp;x 读作: address of x（x的地址）</li>
<li>x.y 读作: member y of object x （对象x的成员y）</li>
<li>(*x).y 读作: member y of object pointed by x（由x指向的对象的成员y）</li>
<li>x-&gt;y 读作: member y of object pointed by x (同上一个等价)</li>
<li>x[0] 读作: first object pointed by x（由x指向的第一个对象）</li>
<li>x[1] 读作: second object pointed by x（由x指向的第二个对象）</li>
<li>x[n] 读作: (n+1)th object pointed by x（由x指向的第n+1个对象）</li>
</ul>
<h3 id="printf-转换类型"><a href="#printf-转换类型" class="headerlink" title="printf()转换类型"></a>printf()转换类型</h3><p>格式转换符是 <code>%td</code></p>
<h3 id="指针相减"><a href="#指针相减" class="headerlink" title="指针相减"></a>指针相减</h3><p>指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单10.13的输出中，ptr2 - ptr1得2，意思是这两个指针所指向的两个元素相隔两个int，而不是2字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。</p>
<h3 id="指针与数组（14-13-P412）"><a href="#指针与数组（14-13-P412）" class="headerlink" title="指针与数组（14.13 P412）"></a>指针与数组（14.13 P412）</h3><p>指针本身的类型, 指针所指向的类型</p>
<p>()和[]的优先度比 * 高。<br>指针名，指针的间隔，指向的变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (* rusks)[<span class="number">10</span>]; <span class="comment">// 声明一个指向数组的指针，该数组内含10个int类型的值</span></span><br><span class="line"><span class="type">int</span> *rusks[<span class="number">10</span>];<span class="comment">//指针数组，内含10个元素，每个元素指向int.</span></span><br><span class="line"><span class="type">double</span> (*pf[<span class="number">10</span>])(<span class="type">double</span>, <span class="type">double</span>);<span class="comment">//函数指针数组，10个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><ol>
<li><p>函数名是函数的地址</p>
</li>
<li><p>定义函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*pf)(<span class="type">char</span> *);<span class="comment">//pf指向一个返回值为void，形参为char *的函数</span></span><br><span class="line"><span class="type">double</span> (*pf[<span class="number">10</span>])(<span class="type">double</span>, <span class="type">double</span>);<span class="comment">//函数指针数组，10个元素</span></span><br><span class="line"><span class="type">double</span> (*pf[])(<span class="type">double</span>, <span class="type">double</span>)=&#123; add, sub, mul, div_i&#125;;<span class="comment">//定义并初始化指针数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *st;</span><br><span class="line">pf(st);</span><br><span class="line">(*pf)(st);</span><br><span class="line"><span class="comment">//两种形式都行</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h3><h2 id="结构体（structure）"><a href="#结构体（structure）" class="headerlink" title="结构体（structure）"></a>结构体（structure）</h2><h3 id="1-设置结构样式、定义结构变量、访问结构体成员"><a href="#1-设置结构样式、定义结构变量、访问结构体成员" class="headerlink" title="1. 设置结构样式、定义结构变量、访问结构体成员"></a>1. 设置结构样式、定义结构变量、访问结构体成员</h3><p>book 是 tag（标记）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span>			<span class="comment">//设置结构体样式。有作用域。book是tag（标记）.</span></span><br><span class="line">    <span class="type">char</span> title[MAXTITL];  <span class="comment">//结构成员列表</span></span><br><span class="line">    <span class="type">char</span> author[MAXAUTL];</span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span>   <span class="comment">//声明结构体变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s by %s: %.2f\n&quot;</span>, library.title, library.author, library.value); <span class="comment">//访问结构体成员</span></span><br><span class="line"><span class="comment">//. 是结构成员运算符，优先级比 &amp; 高</span></span><br></pre></td></tr></table></figure>

<h3 id="2-三种定义结构体变量的方式"><a href="#2-三种定义结构体变量的方式" class="headerlink" title="2. 三种定义结构体变量的方式"></a>2. 三种定义结构体变量的方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 用关键字定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 设置结构体样式时定义变量（有样式名）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> title[MAXTITL];</span><br><span class="line">    <span class="type">char</span> author[MAXAUTL];</span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line">&#125;library;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 没有样式名</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> title[MAXTITL];</span><br><span class="line">    <span class="type">char</span> author[MAXAUTL];</span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line">&#125;library;</span><br></pre></td></tr></table></figure>

<h3 id="3-初始化结构体变量"><a href="#3-初始化结构体变量" class="headerlink" title="3. 初始化结构体变量"></a>3. 初始化结构体变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> title[MAXTITL];</span><br><span class="line">    <span class="type">char</span> author[MAXAUTL];</span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> =</span> &#123;</span><br><span class="line"><span class="string">&quot;The Pious Pirate and the Devious Damsel&quot;</span>,</span><br><span class="line"><span class="string">&quot;Renee Vivotte&quot;</span>,</span><br><span class="line"><span class="number">1.95</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-结构数组"><a href="#4-结构数组" class="headerlink" title="4. 结构数组"></a>4. 结构数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[100];</span></span><br></pre></td></tr></table></figure>

<h3 id="5-嵌套结构"><a href="#5-嵌套结构" class="headerlink" title="5. 嵌套结构"></a>5. 嵌套结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> first[LEN];</span><br><span class="line">    <span class="type">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span></span><br><span class="line">    <span class="type">char</span> favfood[LEN];</span><br><span class="line">    <span class="type">char</span> job[LEN];</span><br><span class="line">    <span class="type">float</span> income;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-指针"><a href="#6-指针" class="headerlink" title="6. 指针"></a>6. 指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span>[2], *<span class="title">him</span>;</span></span><br><span class="line">him=fellow;</span><br><span class="line">him-&gt;income; </span><br><span class="line"><span class="comment">//相当于 (*him).income</span></span><br><span class="line"><span class="comment">//连接号(-)后跟一个大于号(&gt;)</span></span><br><span class="line"><span class="comment">//- 读作 hyphen /ˈhaɪfn/</span></span><br><span class="line"><span class="comment">//&gt; 读作 greater than sign</span></span><br></pre></td></tr></table></figure>

<h3 id="7-向函数传递结构的信息"><a href="#7-向函数传递结构的信息" class="headerlink" title="7. 向函数传递结构的信息"></a>7. 向函数传递结构的信息</h3><p>以结构体变量（不是数组）为参数时，会在函数里创建副本。</p>
<h3 id="8-结构体的复合字面量（结构体常量）-C99"><a href="#8-结构体的复合字面量（结构体常量）-C99" class="headerlink" title="8. 结构体的复合字面量（结构体常量）(C99)"></a>8. 结构体的复合字面量（结构体常量）(C99)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">struct</span> book) &#123;<span class="string">&quot;Crime and Punishment&quot;</span>,</span><br><span class="line"><span class="string">&quot;Fyodor Dostoyevsky&quot;</span>,</span><br><span class="line"><span class="number">11.25</span>&#125;;</span><br><span class="line"><span class="comment">//复合字面量</span></span><br><span class="line"></span><br><span class="line">&amp;(<span class="keyword">struct</span> book) &#123;<span class="string">&quot;Crime and Punishment&quot;</span>,</span><br><span class="line"><span class="string">&quot;Fyodor Dostoyevsky&quot;</span>,</span><br><span class="line"><span class="number">11.25</span>&#125;;</span><br><span class="line"><span class="comment">//复合字面量的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="9-伸缩型数组成员（C99）"><a href="#9-伸缩型数组成员（C99）" class="headerlink" title="9. 伸缩型数组成员（C99）"></a>9. 伸缩型数组成员（C99）</h3><p>结构体的最后一个成员是长度未定的数组。需要由 malloc 指定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">size_t</span> count;</span><br><span class="line"><span class="type">double</span> average;</span><br><span class="line"><span class="type">double</span> scores[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span> * <span class="title">pf1</span>;</span></span><br><span class="line">pf1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> flex) + n * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br></pre></td></tr></table></figure>

<p>特殊的处理要求。第一，不能用结构进行赋值或拷贝：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span> * <span class="title">pf1</span>, *<span class="title">pf2</span>;</span></span><br><span class="line"><span class="comment">// *pf1 和*pf2 都是结构</span></span><br><span class="line">...</span><br><span class="line">*pf2 = *pf1;</span><br><span class="line"><span class="comment">// 不要这样做</span></span><br></pre></td></tr></table></figure>

<p>这样做只能拷贝除伸缩型数组成员以外的其他成员。确实要进行拷贝，应使用memcpy()函数。</p>
<p>第二，不要以按值方式把这种结构传递给结构。原因相同，按值传递一个参数与赋值类似。要把结构的地址传递给函数。</p>
<p>第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员。</p>
<h3 id="10-匿名结构-C11"><a href="#10-匿名结构-C11" class="headerlink" title="10. 匿名结构 (C11)"></a>10. 匿名结构 (C11)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">char</span> first[<span class="number">20</span>]; <span class="type">char</span> last[<span class="number">20</span>];&#125;; <span class="comment">// 匿名结构</span></span><br><span class="line">&#125;;<span class="comment">//设置样式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">ted</span> =</span> &#123;<span class="number">8483</span>, &#123;<span class="string">&quot;Ted&quot;</span>, <span class="string">&quot;Grass&quot;</span>&#125;&#125;;<span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">puts</span>(ted.first);<span class="comment">//引用</span></span><br></pre></td></tr></table></figure>

<h3 id="11-保存结构到文件"><a href="#11-保存结构到文件" class="headerlink" title="11. 保存结构到文件"></a>11. 保存结构到文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>();<span class="comment">//可移植性好，但是太麻烦</span></span><br><span class="line">fwrite();<span class="comment">//可移植性不好，但是很简单</span></span><br></pre></td></tr></table></figure>

<h3 id="12-指定初始化器"><a href="#12-指定初始化器" class="headerlink" title="12. 指定初始化器"></a>12. 指定初始化器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以按照任意顺序使用指定初始化器：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">gift</span> =</span> &#123;</span><br><span class="line">.value = <span class="number">25.99</span>,</span><br><span class="line">.author = <span class="string">&quot;James Broadfool&quot;</span>,</span><br><span class="line">.title = <span class="string">&quot;Rue for the Toad&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="联合（union）数据类型"><a href="#联合（union）数据类型" class="headerlink" title="联合（union）数据类型"></a>联合（union）数据类型</h2><p>union 能存储不同的数据类型；用成员运算符（.）访问，也可用间接成员运算符（-&gt;）用指针访问；有匿名联合。<br>hold 是 tag（标记）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> &#123;</span></span><br><span class="line"><span class="type">int</span> digit;</span><br><span class="line"><span class="type">double</span> bigfl;</span><br><span class="line"><span class="type">char</span> letter;</span><br><span class="line">&#125;;<span class="comment">//声明样式，与structure格式相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valA</span>;</span></span><br><span class="line">valA.letter = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valB</span> =</span> valA; <span class="comment">// initialize one union to another</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valC</span> =</span> &#123;<span class="number">88</span>&#125;; <span class="comment">// initialize digit member of union</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valD</span> =</span> &#123;.bigfl = <span class="number">118.2</span>&#125;; <span class="comment">// designated initializer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问成员</span></span><br><span class="line">fit.digit = <span class="number">23</span>;</span><br><span class="line">pu = &amp;fit;</span><br><span class="line">x = pu-&gt;digit;<span class="comment">// same as x = fit.digit</span></span><br></pre></td></tr></table></figure>

<p>匿名联合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">owner</span> &#123;</span></span><br><span class="line"><span class="type">char</span> socsecurity[<span class="number">12</span>];</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> &#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">40</span>];</span><br><span class="line"><span class="type">char</span> headquarters[<span class="number">40</span>];</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car_data</span> &#123;</span></span><br><span class="line"><span class="type">char</span> make[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> status; <span class="comment">/* 0 = owned, 1 = leased */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">owner</span> <span class="title">owncar</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> <span class="title">leasecar</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="枚举（enumerated-type）"><a href="#枚举（enumerated-type）" class="headerlink" title="枚举（enumerated type）"></a>枚举（enumerated type）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet&#125;;  <span class="comment">//声明枚举样式，与structure格式相同</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> <span class="title">color</span>;</span><span class="comment">//声明变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运用枚举变量</span></span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">color = blue;</span><br><span class="line"><span class="keyword">if</span> (color == yellow)</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">for</span> (color = red; color &lt;= violet; color++)</span><br><span class="line">...;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举变量的值是 int 类型。</li>
<li>默认情况，枚举列表中的常量都被赋予0、1、2等。因此，下面的声明中 nina 的值是3：enum kids {nippy, slats, skippy, nina, liz};</li>
<li>在枚举声明中，可以为枚举常量指定整数值：enum levels {low &#x3D; 100, medium &#x3D; 500, high &#x3D; 2000};</li>
<li>如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被赋予后续的值。例如，假设有如下的声明：enum feline {cat, lynx &#x3D; 10, puma, tiger};那么，cat的值是0（默认），lynx、puma和tiger的值分别是10、11、12。</li>
</ul>
<h2 id="共享名称空间（P410）"><a href="#共享名称空间（P410）" class="headerlink" title="共享名称空间（P410）"></a>共享名称空间（P410）</h2><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/161.html">C语言运算符优先级和结合性一览表</a></p>
<ul>
<li><p>运算符的目: 单目运算符, 双目运算符, 三目运算符</p>
</li>
<li><p>运算符的结合性:  </p>
<ul>
<li>从左到右, 从右到左</li>
<li>只有三个运算符是从右往左的: 单目运算符，三目运算符(?:)，双目运算符中的赋值运算符<code>=</code></li>
</ul>
</li>
<li><p>运算符的优先级: 算术运算符 &gt; 关系运算符 &gt; 逻辑运算符 &gt; 赋值运算符。逻辑运算符中“逻辑非 !”除外。</p>
</li>
</ul>
<h2 id="表B-2-1-C运算符优先级表"><a href="#表B-2-1-C运算符优先级表" class="headerlink" title="表B.2.1 C运算符优先级表"></a>表B.2.1 C运算符优先级表</h2><p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527062.png" alt="image-20221016181749297"></p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="continue-与-break"><a href="#continue-与-break" class="headerlink" title="continue 与 break"></a>continue 与 break</h2><p>continue 和 break 都可用于循环；只有 break 可用于 switch, continue 不可用于 switch；continue 和 switch 都不能用于 if.<br>但是 continue 和 break 可以作为条件语句 ( if, switch) 的一部分，放在<strong>循环语句</strong>里，<strong>这时 continue 和 break 仍起跳出循环的作用</strong>。</p>
<h1 id="函数（function）"><a href="#函数（function）" class="headerlink" title="函数（function）"></a>函数（function）</h1><ul>
<li>parameter与argument辨析</li>
</ul>
<p>虽然常常混用，但C99规定，parameter是形式参数；argument是实际参数，也就是函数调用传递的值。</p>
<h2 id="命令行参数-P311"><a href="#命令行参数-P311" class="headerlink" title="命令行参数 P311"></a>命令行参数 P311</h2><ul>
<li><p>main() 接收命令行参数：int main( int argc, char *argv[])</p>
</li>
<li><p>名为 repeat 的 C 可执行程序在命令行这样接受参数：$ .&#x2F;repeat Resistance</p>
</li>
<li><p>argc（即 argument count）表示命令行中的字符串数量（包括命令名），以空格分割字符串；上面命令的参数数量为 2；</p>
</li>
<li><p>argv（即 argument value）存放每个字符串的地址，argv[0] 存放命令名（即 “repeat”）的地址。</p>
</li>
</ul>
<h1 id="内存分配：malloc-calloc-free"><a href="#内存分配：malloc-calloc-free" class="headerlink" title="内存分配：malloc() calloc() free()"></a>内存分配：malloc() calloc() free()</h1><p>object 与 identifier</p>
<h2 id="malloc-exit-free"><a href="#malloc-exit-free" class="headerlink" title="malloc(), exit(), free()"></a>malloc(), exit(), free()</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>void *malloc( size_t size )</code></td>
<td>分配 size 字节的内存</td>
<td>size_t</td>
<td>以 void* 格式，返回内存的首字节地址</td>
</tr>
<tr>
<td>void exit( int exit_code )</td>
<td>结束程序</td>
<td>int 类型的 exit_code, (EXIT_SUCCESS, EXIT_FAILURE)</td>
<td>exit_code 为EXIT_SUCCESS(即0) ，返回指示成功终止的实现定义状态。<br />exit_code 为 EXIT_FAILURE(即1)，则返回指示不成功终止的实现定义状态。<br />其他情况下返回实现定义的状态值。</td>
</tr>
<tr>
<td><code>void free( void *ptr )</code></td>
<td>释放malloc(), calloc()的内存</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="malloc-的使用"><a href="#malloc-的使用" class="headerlink" title="malloc 的使用"></a>malloc 的使用</h4><p>虽然 malloc() 的 void * 相当于通用指针，但是还是建议用 (double *) 这样的<strong>强制类型转换</strong>，便于阅读和转换为 C++ 程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> *ptr;</span><br><span class="line">ptr = (<span class="type">double</span> *) <span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br></pre></td></tr></table></figure>

<h4 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h4><p>EXIT_SUCCESS 是 0，定义在 stdlib.h；EXIT_FAILURE 是 1，定义在 stdlib.h。</p>
<h2 id="calloc-函数"><a href="#calloc-函数" class="headerlink" title="calloc() 函数"></a>calloc() 函数</h2><p>建议使用强制类型转换和 sizeof() ，方便移植；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">( <span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;  <span class="comment">//函数原型</span></span><br></pre></td></tr></table></figure>

<p>calloc() 按单元数量分配内存，并把所有位设为 0；num 是单元数量，size 是一个单元的字节数；由 free() 释放内存。</p>
<h2 id="动态内存分配和变长数组"><a href="#动态内存分配和变长数组" class="headerlink" title="动态内存分配和变长数组"></a>动态内存分配和变长数组</h2><h2 id="存储类别和动态内存分配"><a href="#存储类别和动态内存分配" class="headerlink" title="存储类别和动态内存分配"></a>存储类别和动态内存分配</h2><p>同一存储类别存储在一起；静态数据（包括字符串变量）存储在一个区域，自动数据存储在一个区域，动态数据存储在一个区域（内存堆&#x2F;自由内存）。</p>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43590796/article/details/107479816#commentBox">为什么有时按两次ctrl+D才能结束标准I&#x2F;O</a></p>
</li>
<li><p>错误原因</p>
</li>
</ul>
<p>在 Ubuntu 里运行这样一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> ch; </span><br><span class="line">        <span class="keyword">while</span>( (ch=getchar())!=<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d|&quot;</span>, ch);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入除 EOF（即<kbd>ctrl</kbd>+<kbd>d</kbd>）之外的字符时，都运行正常；输入 EOF 时，屏幕上一直打印 -1. 猜想当标准输入关闭时，一直发送 EOF.</p>
<p>涉及到关于输入缓冲的知识。输入缓冲分成三种：全缓冲、行缓冲、无缓冲。</p>
<p>​		行缓冲：收到换行符时，刷新缓冲区（换行符也被一起送去）。</p>
<p>总结一下：</p>
<p>　　回车键的效果：将缓冲区连带自身传给CPU，缓冲区清空。</p>
<p>　　ctrl+D（EOF）的效果：将缓冲区不带自身传给CPU，缓冲区清空。</p>
<p>　　缓冲区为空时收到EOF，标准文件输入关闭！</p>
<p>- </p>
<ul>
<li>两次</li>
</ul>
<h2 id="I-x2F-O-示意图"><a href="#I-x2F-O-示意图" class="headerlink" title="I&#x2F;O 示意图"></a>I&#x2F;O 示意图</h2><p>输入输出都是站在内存角度说的</p>
<p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527063.png" alt="image-20221009123241750"></p>
<h2 id="屏幕键盘-I-x2F-O"><a href="#屏幕键盘-I-x2F-O" class="headerlink" title="屏幕键盘 I&#x2F;O"></a>屏幕键盘 I&#x2F;O</h2><h3 id="I-x2F-O函数"><a href="#I-x2F-O函数" class="headerlink" title="I&#x2F;O函数"></a>I&#x2F;O函数</h3><p><strong>目的地位置：</strong></p>
<ul>
<li>fread&#x2F;fwrite，getc&#x2F;putc的变体（fgetc&#x2F;fputc, fgets&#x2F;fputs），都把文件指针放在最后</li>
<li>printf&#x2F;scanf的变体（fprintf&#x2F;fscanf, sprintf&#x2F;sscanf）都把目的地放在最前。</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li><p>fread&#x2F;fwrite是二进制模式输入输出。</p>
</li>
<li><p>get&#x2F;put类的函数（getchar&#x2F;putchar, fgets&#x2F;fputs, gets(已废除)&#x2F;puts）都是字符&#x2F;字符串输入输出。文本模式。</p>
</li>
<li><p>printf&#x2F;scanf及其变体（fprintf&#x2F;fscanf, sprintf&#x2F;sscanf）都是格式化输出&#x2F;输入。文本模式。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//从stdin接收字符作为返回值输出内存</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span> <span class="params">(<span class="type">int</span> ch)</span>;  <span class="comment">//输出变量ch的字符到stdin</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span> <span class="params">(<span class="type">char</span> *ch)</span>;</span><br><span class="line"><span class="comment">//gets()接收一行字符，即遇到换行符时停止，然后丢弃换行符，存储其余字符，并在末尾加上空字符</span></span><br><span class="line"><span class="comment">//在c11中，gets函数已经被废除，因为内存溢出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ch)</span>;</span><br><span class="line"><span class="comment">//puts()显示字符串，并在末尾加上换行符</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *str, <span class="type">int</span> count, FILE *stream )</span></span><br><span class="line"><span class="comment">//fgets()遇到换行符时停止输入，并且会接收换行符</span></span><br><span class="line"><span class="comment">//count表示数组元素的数量，然后把最后一个变量赋为空字符</span></span><br><span class="line"><span class="comment">//如果一切进行顺利，该函数返回的地址与传入的第 1 个参数相同。</span></span><br><span class="line"><span class="comment">//如果函数只获取了EOF没有读到任何其它内容，它将返回空指针（null pointer）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, FILE *stream )</span>;</span><br><span class="line"><span class="comment">//输出时不会添加换行符</span></span><br><span class="line"><span class="comment">//与fgets配套使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *format, ... )</span>;  <span class="comment">//格式化字符串，变量列表（variable list）。接收一个单词（即空白处停止输入）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *format, ... )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ... )</span>  <span class="comment">//文件指针，格式化字符串，变量列表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> * ormat, ... )</span>;<span class="comment">//可以输出到stderr</span></span><br></pre></td></tr></table></figure>
<h3 id="转换说明"><a href="#转换说明" class="headerlink" title="转换说明"></a>转换说明</h3><p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527064.png" alt="image-20221013113142062"></p>
<h3 id="转换说明修饰符"><a href="#转换说明修饰符" class="headerlink" title="转换说明修饰符"></a>转换说明修饰符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> : %zd</span><br><span class="line">*: 由参数指定字段宽度。可变字段宽度。</span><br></pre></td></tr></table></figure>

<p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527065.png" alt="image-20221013113404923"></p>
<h3 id="输出特殊字符"><a href="#输出特殊字符" class="headerlink" title="输出特殊字符"></a>输出特殊字符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出%: %%</span><br></pre></td></tr></table></figure>



<h2 id="磁盘文件-I-x2F-O"><a href="#磁盘文件-I-x2F-O" class="headerlink" title="磁盘文件 I&#x2F;O"></a>磁盘文件 I&#x2F;O</h2><h3 id="文本文件与二进制文件"><a href="#文本文件与二进制文件" class="headerlink" title="文本文件与二进制文件"></a>文本文件与二进制文件</h3><ul>
<li>文本文件：以字符编码形式存储到磁盘文件</li>
<li>二进制文件：将内存数据原样存储到磁盘文件</li>
<li>二进制模式：模式字符串加b</li>
</ul>
<p>eg: 浮点数以文本模式输出到文件后，就成为了字符串</p>
<h3 id="换行与文件结尾"><a href="#换行与文件结尾" class="headerlink" title="换行与文件结尾"></a>换行与文件结尾</h3><table>
<thead>
<tr>
<th>系统</th>
<th>换行</th>
<th>结尾</th>
</tr>
</thead>
<tbody><tr>
<td>UNIX&#x2F;Linux</td>
<td>\n (换行符)</td>
<td>记录文件大小，计数确认是否读到结尾</td>
</tr>
<tr>
<td>OS X Macintosh</td>
<td>\r (回车符)</td>
<td></td>
</tr>
<tr>
<td>MS-DOS</td>
<td>\r\n</td>
<td>Ctrl+z</td>
</tr>
<tr>
<td>Windows</td>
<td>Notepad 生成 MS-DOS 格式的文件，新的编辑器生成类 UNIX 格式的文件</td>
<td>Notepad 生成 MS-DOS 格式的文件，新的编辑器生成类 UNIX 格式的文件</td>
</tr>
</tbody></table>
<p>两种访问模式，<strong>文本模式</strong>和<strong>二进制模式</strong>：</p>
<ol>
<li>文本模式：把本地系统的格式转换成 C 的格式，比如在 MS-DOS 系统上把 \r\n 转换成 \n；</li>
<li>二进制模式：在二进制模式，程序能访问文件的每一个字节；文件格式不会被转换；</li>
</ol>
<p>UNIX 用同一种格式处理文本文件和二进制文件，所以<strong>这两种模式对 UNIX 相同</strong>。</p>
<p>getc() 读到结尾返回EOF。<strong>程序一定会读到超过文件末尾。</strong></p>
<h3 id="fopen-和-fclose"><a href="#fopen-和-fclose" class="headerlink" title="fopen() 和 fclose()"></a>fopen() 和 fclose()</h3><ul>
<li><p>文本模式：将内存里的位组合转化为<strong>字符编码</strong>。</p>
</li>
<li><p>二进制模式：按内存里的位组合写入到文件；</p>
</li>
</ul>
<p>fopen() 和 fclose()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fopen(<span class="string">&quot;filename&quot;</span>, mode);</span><br><span class="line">fclose(FILE *);</span><br></pre></td></tr></table></figure>

<h3 id="fopen-的模式字符串"><a href="#fopen-的模式字符串" class="headerlink" title="fopen()的模式字符串"></a>fopen()的模式字符串</h3><p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527066.png" alt="image-20220510235440367"></p>
<table>
<thead>
<tr>
<th>模式字符串</th>
<th>含义、能否控制读写开始的位置</th>
</tr>
</thead>
<tbody><tr>
<td>“r”</td>
<td>只能读</td>
</tr>
<tr>
<td>“w”</td>
<td>只能重新写</td>
</tr>
<tr>
<td>“a”</td>
<td>只能在末尾添加</td>
</tr>
<tr>
<td>“r+”</td>
<td>最自由的模式。从文件指针的位置开始读写。</td>
</tr>
<tr>
<td>“w+”</td>
<td>从文件指针位置开始读；写时会先把所有文件数据抹掉重新写。先抹再写。</td>
</tr>
<tr>
<td>“a+”</td>
<td>从文件指针位置开始读；不能控制写开始的位置，只能在末尾添加</td>
</tr>
</tbody></table>
<p>文件指针与数组类似，偏移量像下标。至少文本文件有 EOF。</p>
<h3 id="fseek-和-ftell"><a href="#fseek-和-ftell" class="headerlink" title="fseek() 和 ftell()"></a>fseek() 和 ftell()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span> <span class="params">(FILE *, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> starting_point)</span>;</span><br><span class="line"><span class="comment">//形参：文件指针、偏移量、模式</span></span><br><span class="line"><span class="comment">//偏移量:向左为负，向右为正；在数字后加L后缀</span></span><br><span class="line"><span class="comment">//模式：SEEK_SET（文件开头）, SEEK_CUR（当前位置）, SEEK_END（文件末尾，即EOF）.</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="comment">//当前位置-文件起点。当前位置到文件开头的字节数。</span></span><br></pre></td></tr></table></figure>
<h3 id="fgetpos-和fsetpos"><a href="#fgetpos-和fsetpos" class="headerlink" title="fgetpos()和fsetpos()"></a>fgetpos()和fsetpos()</h3><p>适用于大文件。fseek()和ftell()适用于long大小的文件。</p>
<h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h3><h3 id="文件指针是怎么移动的？"><a href="#文件指针是怎么移动的？" class="headerlink" title="文件指针是怎么移动的？"></a>文件指针是怎么移动的？</h3><p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527068.png" alt="IMG_0835"></p>
<h3 id="I-x2F-O-函数"><a href="#I-x2F-O-函数" class="headerlink" title="I&#x2F;O 函数"></a>I&#x2F;O 函数</h3><p><strong>目的地位置：</strong></p>
<ul>
<li>fread&#x2F;fwrite，getc&#x2F;putc的变体（fgetc&#x2F;fputc, fgets&#x2F;fputs），都把文件指针放在最后</li>
<li>printf&#x2F;scanf的变体（fprintf&#x2F;fscanf, sprintf&#x2F;sscanf）都把目的地放在最前。</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li><p>fread&#x2F;fwrite是二进制模式输入输出。</p>
</li>
<li><p>get&#x2F;put类的函数（getchar&#x2F;putchar, fgets&#x2F;fputs, gets(已废除)&#x2F;puts）都是字符&#x2F;字符串输入输出。文本模式。</p>
</li>
<li><p>printf&#x2F;scanf及其变体（fprintf&#x2F;fscanf, sprintf&#x2F;sscanf）都是格式化输出&#x2F;输入。文本模式。</p>
</li>
</ul>
<h4 id="fread-x2F-fwrite"><a href="#fread-x2F-fwrite" class="headerlink" title="fread&#x2F;fwrite"></a>fread&#x2F;fwrite</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *fp)</span>;</span><br><span class="line"><span class="comment">//二进制模式输出数据</span></span><br><span class="line"><span class="comment">//fwrite()函数返回成功写入项的数量。正常情况下，该返回值就是nmemb，但如果出现写入错误，返回值会比nmemb小。</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *fp)</span>;</span><br><span class="line"><span class="comment">//二进制模式读取数据。返回读取成功的项的数量。</span></span><br></pre></td></tr></table></figure>

<h4 id="get-x2F-put类函数（字符-x2F-字符串-I-x2F-O）"><a href="#get-x2F-put类函数（字符-x2F-字符串-I-x2F-O）" class="headerlink" title="get&#x2F;put类函数（字符&#x2F;字符串 I&#x2F;O）"></a>get&#x2F;put类函数（字符&#x2F;字符串 I&#x2F;O）</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bwangel23/p/4159414.html">C语言中fgetc、fputc和getc、putc的区别是什么</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">( FILE *stream )</span>;  </span><br><span class="line"><span class="comment">//从文件流stream里取一个字符到内存作为返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">( <span class="type">int</span> ch , FILE *stream)</span>;  </span><br><span class="line"><span class="comment">//把变量ch里的字符输出到文件流stream</span></span><br><span class="line"><span class="comment">//成功时，返回被写入字符；失败时，返回 EOF 并设置 stream 上的错误指示器（见 ferror() ）。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">( FILE *stream)</span>;</span><br><span class="line"><span class="comment">//从文件流stream里取一个字符到内存作为返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch , FILE *stream)</span>;</span><br><span class="line"><span class="comment">//把变量ch里的字符输出到文件流stream</span></span><br><span class="line"><span class="comment">//成功时，返回被写入字符；失败时，返回 EOF 并设置 stream 上的错误指示器（见 ferror() ）。</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *str, <span class="type">int</span> count, FILE *stream )</span></span><br><span class="line"><span class="comment">//fgets()遇到换行符时停止输入，并且会接收换行符</span></span><br><span class="line"><span class="comment">//count表示数组元素的数量，然后把最后一个变量赋为空字符</span></span><br><span class="line"><span class="comment">//如果一切进行顺利，该函数返回的地址与传入的第 1 个参数相同。</span></span><br><span class="line"><span class="comment">//如果函数只获取了EOF没有读到任何其它内容，它将返回空指针（null pointer）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, FILE *stream )</span>;</span><br><span class="line"><span class="comment">//输出时不会添加换行符</span></span><br><span class="line"><span class="comment">//与fgets配套使用</span></span><br></pre></td></tr></table></figure>

<h4 id="scanf-x2F-printf类函数（格式化I-x2F-O）"><a href="#scanf-x2F-printf类函数（格式化I-x2F-O）" class="headerlink" title="scanf&#x2F;printf类函数（格式化I&#x2F;O）"></a>scanf&#x2F;printf类函数（格式化I&#x2F;O）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ... )</span>  <span class="comment">//文件指针，格式化字符串，变量列表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> * ormat, ... )</span>;<span class="comment">//可以输出到stderr</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format, ... )</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">( <span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format, ... )</span>;<span class="comment">//按格式把数据输入字符串（字符数组）</span></span><br></pre></td></tr></table></figure>

<h4 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h4><p>以下内容在纸质书P367</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *fp, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">//_IOFBF means fully buffered</span></span><br><span class="line"><span class="comment">//_IOLBF means line-buffered</span></span><br><span class="line"><span class="comment">//_IONBF means nonbuffered</span></span><br><span class="line"><span class="comment">//如果操作成功，函数返回0，否则返回一个非零值。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">//当上一次输入调用检测到文件结尾时，feof()函数返回一个非零值，否则返回0。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">//当读或写出现错误，ferror()函数返回一个非零值，否则返回0。</span></span><br></pre></td></tr></table></figure>

<h2 id="I-x2F-O-函数总结"><a href="#I-x2F-O-函数总结" class="headerlink" title="I&#x2F;O 函数总结"></a>I&#x2F;O 函数总结</h2><h3 id="fread-x2F-fwrite-1"><a href="#fread-x2F-fwrite-1" class="headerlink" title="fread&#x2F;fwrite"></a>fread&#x2F;fwrite</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *fp)</span>;</span><br><span class="line"><span class="comment">//二进制模式输出数据</span></span><br><span class="line"><span class="comment">//fwrite()函数返回成功写入项的数量。正常情况下，该返回值就是nmemb，但如果出现写入错误，返回值会比nmemb小。</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *fp)</span>;</span><br><span class="line"><span class="comment">//二进制模式读取数据。返回读取成功的项的数量。</span></span><br></pre></td></tr></table></figure>

<h3 id="get-x2F-put类函数（字符-x2F-字符串-I-x2F-O）-1"><a href="#get-x2F-put类函数（字符-x2F-字符串-I-x2F-O）-1" class="headerlink" title="get&#x2F;put类函数（字符&#x2F;字符串 I&#x2F;O）"></a>get&#x2F;put类函数（字符&#x2F;字符串 I&#x2F;O）</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bwangel23/p/4159414.html">C语言中fgetc、fputc和getc、putc的区别是什么</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//从stdin接收字符作为返回值输出内存</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span> <span class="params">(<span class="type">int</span> ch)</span>;  <span class="comment">//输出变量ch的字符到stdin</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">( FILE *stream )</span>;  </span><br><span class="line"><span class="comment">//从文件流stream里取一个字符到内存作为返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">( <span class="type">int</span> ch , FILE *stream)</span>;  </span><br><span class="line"><span class="comment">//把变量ch里的字符输出到文件流stream</span></span><br><span class="line"><span class="comment">//成功时，返回被写入字符；失败时，返回 EOF 并设置 stream 上的错误指示器（见 ferror() ）。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">( FILE *stream)</span>;</span><br><span class="line"><span class="comment">//从文件流stream里取一个字符到内存作为返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch , FILE *stream)</span>;</span><br><span class="line"><span class="comment">//把变量ch里的字符输出到文件流stream</span></span><br><span class="line"><span class="comment">//成功时，返回被写入字符；失败时，返回 EOF 并设置 stream 上的错误指示器（见 ferror() ）。</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span> <span class="params">(<span class="type">char</span> *ch)</span>;</span><br><span class="line"><span class="comment">//gets()接收一行字符，即遇到换行符时停止，然后丢弃换行符，存储其余字符，并在末尾加上空字符</span></span><br><span class="line"><span class="comment">//在c11中，gets函数已经被废除，因为内存溢出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ch)</span>;</span><br><span class="line"><span class="comment">//puts()显示字符串，并在末尾加上换行符</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *str, <span class="type">int</span> count, FILE *stream )</span></span><br><span class="line"><span class="comment">//fgets()遇到换行符时停止输入，并且会接收换行符</span></span><br><span class="line"><span class="comment">//count表示数组元素的数量，然后把最后一个变量赋为空字符</span></span><br><span class="line"><span class="comment">//如果一切进行顺利，该函数返回的地址与传入的第 1 个参数相同。</span></span><br><span class="line"><span class="comment">//如果函数只获取了EOF没有读到任何其它内容，它将返回空指针（null pointer）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, FILE *stream )</span>;</span><br><span class="line"><span class="comment">//输出时不会添加换行符</span></span><br><span class="line"><span class="comment">//与fgets配套使用</span></span><br></pre></td></tr></table></figure>

<h3 id="scanf-x2F-printf类函数（格式化I-x2F-O）-1"><a href="#scanf-x2F-printf类函数（格式化I-x2F-O）-1" class="headerlink" title="scanf&#x2F;printf类函数（格式化I&#x2F;O）"></a>scanf&#x2F;printf类函数（格式化I&#x2F;O）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *format, ... )</span>;  <span class="comment">//格式化字符串，变量列表（variable list）。接收一个单词（即空白处停止输入）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *format, ... )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ... )</span>  <span class="comment">//文件指针，格式化字符串，变量列表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> * ormat, ... )</span>;<span class="comment">//可以输出到stderr</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format, ... )</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">( <span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format, ... )</span>;<span class="comment">//按格式把数据输入字符串（字符数组）</span></span><br></pre></td></tr></table></figure>

<h3 id="其它函数-1"><a href="#其它函数-1" class="headerlink" title="其它函数"></a>其它函数</h3><p>以下内容在纸质书P367</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *fp, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">//_IOFBF means fully buffered</span></span><br><span class="line"><span class="comment">//_IOLBF means line-buffered</span></span><br><span class="line"><span class="comment">//_IONBF means nonbuffered</span></span><br><span class="line"><span class="comment">//如果操作成功，函数返回0，否则返回一个非零值。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">//当上一次输入调用检测到文件结尾时，feof()函数返回一个非零值，否则返回0。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">//当读或写出现错误，ferror()函数返回一个非零值，否则返回0。</span></span><br></pre></td></tr></table></figure>


<h1 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>$$<br>7&#x3D;2\times 3+1&#x3D;2\times(2\times1+1)+1&#x3D;2^2\times1+2^1\times1+2^0\times1&#x3D;111_{(2)}<br>$$</p>
<table>
<thead>
<tr>
<th>16进制</th>
<th>0x1</th>
<th>0x2</th>
<th>0x3</th>
<th>0x4</th>
<th>0x5</th>
<th>0x6</th>
<th>0x7</th>
<th>0x8</th>
<th>0x9</th>
<th>0xa</th>
<th>0xb</th>
<th>0xc</th>
<th>0xd</th>
<th>0xe</th>
<th>0xf</th>
</tr>
</thead>
<tbody><tr>
<td>2进制</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
<td>1000</td>
<td>1001</td>
<td>1010</td>
<td>1011</td>
<td>1100</td>
<td>1101</td>
<td>1110</td>
<td>1111</td>
</tr>
</tbody></table>
<h2 id="按位逻辑运算符"><a href="#按位逻辑运算符" class="headerlink" title="按位逻辑运算符"></a>按位逻辑运算符</h2><p>该操作产生了一个新的位值，但是不改变其运算对象。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">~</td>
<td align="left">按位非</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="left">按位与</td>
</tr>
<tr>
<td align="center">|</td>
<td align="left">按位或</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">按位异或（相同为1，不同为0）</td>
</tr>
<tr>
<td align="center">&amp;&#x3D;</td>
<td align="left">按位与赋值</td>
</tr>
<tr>
<td align="center">|&#x3D;</td>
<td align="left">按位或赋值</td>
</tr>
<tr>
<td align="center">^&#x3D;</td>
<td align="left">按位异或赋值</td>
</tr>
</tbody></table>
<h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>该操作产生了一个新的位值，但是不改变其运算对象。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td>右移<br />对于无符号类型，用 0 填充空出的位置；对于有符号类型，其结果取决于机器。</td>
</tr>
<tr>
<td align="center">&lt;&lt;&#x3D;</td>
<td>左移赋值</td>
</tr>
<tr>
<td align="center">&gt;&gt;&#x3D;</td>
<td>右移赋值</td>
</tr>
</tbody></table>
<h2 id="位字段（位域）（bitfields）"><a href="#位字段（位域）（bitfields）" class="headerlink" title="位字段（位域）（bitfields）"></a>位字段（位域）（bitfields）</h2><p>C 标准中只允许 <code>unsigned int</code>、<code>signed int</code>、<code>int</code> 类型的位域申明，C99又增加了 <code>bool</code> 类型的支持；<br>一些编译器像 <code>gcc</code>、<code>msvc</code>等自行加入了一些扩展，使得其他的类型(<code>short、char</code>等)也支持位域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> autfd: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bldfc: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> undln: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> itals:	<span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> is	: <span class="number">1</span>;</span><br><span class="line">&#125; prnt;</span><br></pre></td></tr></table></figure>

<p>bool 的成员可以赋值 true 或 false.<br>可用未命名字段对齐。若用长度为0的未命名字段对齐，会在其后新建一个变量。</p>
<h1 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h1><h2 id="typedef（P411）"><a href="#typedef（P411）" class="headerlink" title="typedef（P411）"></a>typedef（P411）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> + 定义形式;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*V_FP_CHARP)</span><span class="params">(<span class="type">char</span> *)</span>; <span class="comment">//定义了V_FP_CHARP. 被定义的标识符代替了过程。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span> <span class="params">(V_FP_CHARP fp, <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h2><p>#define 可用来定义符号常量。宏（macro）的名称中不允许有空格，ANSI C允许在参数列表中使用空格。而且必须遵循C变量的命名规则：只能使用字符、数字和下划线（_）字符，而且首字符不能是数字。</p>
<p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527069.png" alt="image-20221028015011129"></p>
<p>带有参数的宏</p>
<p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527070.png" alt="image-20221028130153811"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"><span class="comment">//SQUARE(x+2)⇒x+2*x+2</span></span><br><span class="line"><span class="comment">//100/SQUARE(2)⇒100/2*2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以最好多加括号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) ((X)*(X))</span></span><br></pre></td></tr></table></figure>

<p>#运算符：将参数转换为字符串，利用字符串的串联特性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PSQR(X) printf(<span class="string">&quot;The square of &quot;</span> #X <span class="string">&quot; is %d.\n&quot;</span>, ((X)*(X)))</span></span><br><span class="line"><span class="type">int</span> y=<span class="number">5</span>;</span><br><span class="line">PSQR(y);</span><br><span class="line"><span class="comment">//替换后的结果是</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The square of &quot;</span><span class="string">&quot;y&quot;</span><span class="string">&quot; is %d.\n&quot;</span>, ((y)*(y)));</span><br></pre></td></tr></table></figure>

<p>##运算符：将两个标识符组合成一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XNAME(n) x ## n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_XN(n) printf(<span class="string">&quot;x&quot;</span> #n <span class="string">&quot; = %d\n&quot;</span>, x ## n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(<span class="number">1</span>)</span>= <span class="number">14</span>;	<span class="comment">//becomes int x1= 14;</span></span><br><span class="line">PRINT_XN(<span class="number">1</span>);	<span class="comment">//becomes printf(&quot;x1 = %d\n&quot;, x1);</span></span><br></pre></td></tr></table></figure>

<p>变参宏。<code>...</code>和<code>__VA_ARGS__</code>。省略号只能代替最后的宏参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PR(X, ...) printf(<span class="string">&quot;Message &quot;</span> #X <span class="string">&quot;: &quot;</span> _ _VA_ARGS_ _)</span></span><br></pre></td></tr></table></figure>

<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> 			#查找系统目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hot.h&quot;</span> 			#查找当前工作目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/usr/biff/p.h&quot;</span>  	#查找/usr/biff目录</span></span><br></pre></td></tr></table></figure>

<h2 id="其它def预处理指令"><a href="#其它def预处理指令" class="headerlink" title="其它def预处理指令"></a>其它def预处理指令</h2><p><code>#undef</code> : 取消 <code>#define</code> 定义的宏。<br><code>#ifdef</code> , <code>#else</code> , <code>#endif</code> : 条件编译。eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAVIS</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;horse.h&quot;</span> <span class="comment">// gets done if MAVIS is #defined</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> STABLES 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cow.h&quot;</span>   <span class="comment">// gets done if MAVIS isn&#x27;t #defined</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> STABLES</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>#ifndef</code> , <code>#endif</code> : 条件编译。eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>#if</code> 和 <code>#elif</code>. 可以在指令中使用 C 的关系运算符和逻辑运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> SYS == 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ibm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYS == 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ibmpc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SYS == 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vax.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SYS == 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;general.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><p><img src="https://illyber-images.oss-cn-chengdu.aliyuncs.com/202301281527071.png" alt="预定义宏"></p>
<h2 id="line"><a href="#line" class="headerlink" title="#line"></a>#line</h2><p>重新设置行号和文件名</p>
<h2 id="error"><a href="#error" class="headerlink" title="#error"></a>#error</h2><p>输出指定的错误信息</p>
<h2 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h2><p>把编译器指令放入源代码中</p>
<p>_Pragma 把字符串转换为编译指示</p>
<h2 id="Generic"><a href="#Generic" class="headerlink" title="_Generic"></a>_Generic</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_Generic</span>(x, <span class="type">int</span>:<span class="number">0</span>, <span class="type">float</span>:<span class="number">1</span>, <span class="keyword">default</span>:<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="内联函数（inline-function-C99"><a href="#内联函数（inline-function-C99" class="headerlink" title="内联函数（inline function)(C99)"></a>内联函数（inline function)(C99)</h2><ol>
<li>唯二的函数说明符之一</li>
<li>内联函数定义必须与调用该函数的代码在一个文件</li>
<li>如果别的文件要调用内联函数，可以把内联函数定义放在头文件，这是个例外，一般头文件不放定义。</li>
</ol>
<h2 id="Noreturn"><a href="#Noreturn" class="headerlink" title="_Noreturn"></a>_Noreturn</h2><ol>
<li>唯二的函数说明符之一</li>
<li>调用完该函数之后，不返回主调函数</li>
</ol>
<h1 id="C-库"><a href="#C-库" class="headerlink" title="C 库"></a>C 库</h1><h2 id="历史-void指针"><a href="#历史-void指针" class="headerlink" title="历史-void指针"></a>历史-void指针</h2><p>ANSI C 有void指针，void 指针用于指针类型不确定的情况。</p>
<h2 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h2><ul>
<li>数学库里三角函数的自变量是弧度</li>
<li>atan()不能区分象限，atan2()能区分象限</li>
</ul>
<h2 id="通用工具库"><a href="#通用工具库" class="headerlink" title="通用工具库"></a>通用工具库</h2><ul>
<li>int atexit( void (*func)(void) )</li>
</ul>
<p>register function. 将 *func 入栈，ANSI C容量是32个函数；调用exit()时执行栈内函数，后进先出；main()结束时会自动隐形调用exit()</p>
<ul>
<li>exit()</li>
</ul>
<p>0: 成功，非零：失败。</p>
<p>或用预定义宏：EXIT_SUCCESS, EXIT_FAILURE</p>
<ul>
<li><p>qsort()。快速排序。</p>
</li>
<li><p><code>void qsort( void *base, size_t nmemb, size_t size, int (* compar)(const void *, const void *))</code></p>
<ul>
<li>void *。C语言中，任何指针都可以赋值给void指针；C++ 中必须要强制类型转换</li>
<li>base. 数组的首元素地址；</li>
<li>nmemb. number of memory by bytes. 要比较的项的数量；</li>
<li>size. 单元素的字节大小。因为用void指针，不知道数组元素大小；</li>
<li>compar. 函数指针，该函数用于比较。规定：如果第一个元素大于第二个，返回正数；相等，0；小于，负数。<ul>
<li>compar 内部。要用对应的元素指针访问元素，要对void *变量强制类型转换。为了方便移植到C++</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="The-Assert-Library"><a href="#The-Assert-Library" class="headerlink" title="The Assert Library"></a>The Assert Library</h2><ul>
<li>assert()<ul>
<li><p>用 assert.h 头文件；assert() 是一个宏</p>
</li>
<li><p>assert() 里放整型表达式（关系表达式和逻辑表达式）</p>
</li>
<li><p>用于debug。如果表达式为假，会输出错误信息帮助debug</p>
</li>
<li><p>在 #include&lt;assert.h&gt; 前放#define NDEBUG，编译器会禁用所有assert()语句</p>
</li>
<li><pre><code class="c">//在标头 &lt;assert.h&gt; 定义
#ifdef NDEBUG
#define assert(condition) ((void)0)
#else
#define assert(condition) /*implementation defined*/
#endif
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- `_Static_assert(表达式, 消息)`(C11)</span><br><span class="line">  </span><br><span class="line">  - 不需要include assert.h</span><br><span class="line">  - 第一个参数：整型常量表达式；第二个参数：字符串。sizeof表达式被视为整型常量</span><br><span class="line">  - 在编译时检查第一个参数，如果错，就显示字符串</span><br><span class="line"></span><br><span class="line">## memcpy()和memmove()</span><br><span class="line"></span><br><span class="line">- void *memcpy( void * restrict  s1, const void * restrict s2, size_t n)</span><br><span class="line">- void *memmove( void * s1, const void * s2, size_t n)</span><br><span class="line">- 两者函数原型都位于string.h</span><br><span class="line">- 都是从s2复制到s1, memmove()不是移动</span><br><span class="line">- memcpy()假设两块内存没有重叠</span><br><span class="line"></span><br><span class="line"># 存储类别 storage classes</span><br><span class="line"></span><br><span class="line">## 变量的存储类别</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line"></span><br><span class="line">- storage duration → scope → linkage</span><br><span class="line"></span><br><span class="line">- 对象（object）：用来存储值的一块内存。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 标识符（identifier）：标识内存块的符号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 左值（lvalue），可修改的左值（modifiable lvalue）。标识符是左值。</span><br><span class="line"></span><br><span class="line">- 赋值操作只能发生在函数内，不能发生在函数外</span><br><span class="line">- extern 用于声明而非定义</span><br><span class="line">- 翻译单元。头文件+C代码文件，即预编译后的文件</span><br><span class="line"></span><br><span class="line">| 链接(linkage)                      | 作用域(scope)                                                | 存储期(scope duration)              |</span><br><span class="line">| ---------------------------------- | ------------------------------------------------------------ | ----------------------------------- |</span><br><span class="line">| 无链接(none linkage)               | 块作用域(block scope)、函数原型作用域(function prototype scope)、函数作用域(function scope) | 自动存储期(auto)/静态存储期(static) |</span><br><span class="line">| 内部链接(internal linkage)(static) | 内部链接的**文件作用域**(file scope with internal linkage)/文件作用域(file scope) | 静态存储期                          |</span><br><span class="line">| 外部链接(external linkage)(extern) | 外部链接的**文件作用域**(file scope with external linkage)/程序作用域(program scope)/全局作用域(global scope) | 静态存储期                          |</span><br><span class="line"></span><br><span class="line">|              | 存储期 | 作用域 | 链接 | 声明方式           |</span><br><span class="line">| ------------ | ------ | ------ | ---- | ------------------ |</span><br><span class="line">| 自动         | 自动   | 块     | 无   | 块内               |</span><br><span class="line">| 寄存器       | 自动   | 块     | 无   | 块内，register     |</span><br><span class="line">| 静态外部链接 | 静态   | 文件   | 外部 | 所有函数外         |</span><br><span class="line">| 静态内部链接 | 静态   | 文件   | 内部 | 所有函数外，static |</span><br><span class="line">| 静态无连接   | 静态   | 块     | 无   | 块内，static       |</span><br><span class="line"></span><br><span class="line">### 作用域scope</span><br><span class="line"></span><br><span class="line">作用域：标识符可被访问的程序范围。由compiler处理</span><br><span class="line"></span><br><span class="line">翻译单元（translation unit）：预编译后的 头文件+c源码文件</span><br><span class="line"></span><br><span class="line">- 块的定义和块作用域</span><br><span class="line"></span><br><span class="line">  - 块作用域（block scope）1：被花括号括起来的部分被称为块（block）；在块里声明的变量，在块以外就无法访问，编译器编译时会提示 undeclared；</span><br><span class="line"></span><br><span class="line">  - 块作用域2：函数头里声明的形式参数与函数体里的变量同属一个函数块。</span><br><span class="line">    - C99新特性1：可在块中任意位置声明变量，C99以前只能在块开头的地方声明；</span><br><span class="line">    - C99新特性2：循环语句（for, while, do...while）和 if 语句自成一个块，即使这些语句没有花括号；循环体是循环块的子块，循环头是循环块，if 语句同理。</span><br><span class="line"></span><br><span class="line">  - 块作用域3：普通块，语句块（c99 新增：while, do...while, for, if 块），函数块。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 函数作用域（function scope）仅用于 goto 语句的标签。</span><br><span class="line">- 函数原型作用域（function prototype scope）：用于函数原型中的形参名；范围是从声明处到函数原型结束；所以函数原型中的形参名通常无关紧要。</span><br><span class="line">- 文件作用域（file scope）/全局变量（global variable）：在函数外声明的变量。</span><br><span class="line"></span><br><span class="line">### 链接linkage</span><br><span class="line"></span><br><span class="line">由linker处理</span><br><span class="line"></span><br><span class="line">- 无连接：不能被其它文件引用。具有**块作用域**、**函数作用域**、**函数原型作用域**的变量都是无链接变量。</span><br><span class="line">- 内部链接（外部链接的文件作用域）：只能用在**当前翻译单元**；声明前加关键字 static；简称为全局作用域/程序作用域；</span><br><span class="line"></span><br><span class="line">- 外部链接（内部链接的文件作用域）：能作用于**多个翻译单元**；简称为文件作用域；</span><br><span class="line">  - 定义时不加 extern；在其它翻译单元引用时要用extern引用式声明。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">int giants = 5;  //外部链接</span><br><span class="line">static int dodgers = 3;  //内部链接</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="存储期-storage-duration"><a href="#存储期-storage-duration" class="headerlink" title="存储期 storage duration"></a>存储期 storage duration</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>链接描述了能通过标识符访问对应对象的范围，存储期描述了对象的存续时间。</p>
<ul>
<li><p>静态存储期：在整个程序运行期间一直存在；在变量声明前加 static 关键字就可声明静态存储期变量；文件作用域变量都具有静态存储期，static 关键字只表明该变量是内部链接变量；定义在函数体内的静态变量一直存在，但其他函数不能直接<strong>访问</strong>，可以通过返回值或地址间接访问；</p>
</li>
<li><p>线程存储期：从被声明到线程结束，一直存在；以关键字 _Thread_local声明一个对象时，每个线程都获得该变量的私有拷贝；</p>
</li>
<li><p>自动存储期：块作用域变量都具有自动存储期 (auto)，进入块时为变量分配对象，块结束处会释放变量，<strong>变长数组</strong>从声明处到块的末尾；</p>
</li>
<li><p>动态分配存储期：</p>
</li>
<li><p><strong>5 种混合存储类别：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>存储期</th>
<th>作用域</th>
<th>链接</th>
<th>声明方式</th>
</tr>
</thead>
<tbody><tr>
<td>自动</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内</td>
</tr>
<tr>
<td>寄存器</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td><code>块内，register</code></td>
</tr>
<tr>
<td>静态外部链接</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>所有函数外</td>
</tr>
<tr>
<td>静态内部链接</td>
<td>静态</td>
<td>文件</td>
<td>内部</td>
<td><code>所有函数外，static</code></td>
</tr>
<tr>
<td>静态无连接</td>
<td>静态</td>
<td>块</td>
<td>无</td>
<td><code>块内，static</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><ul>
<li><p>自动变量：块作用域、自动存储期、无链接</p>
</li>
<li><p>嵌套隐藏：块里再嵌套块，被嵌套的块是子块（sub-block）；如果内层块与外层块声明了<strong>同名变量</strong>，执行进内层块的时候，外层同名变量会被隐藏；</p>
<ul>
<li>循环体是整个<strong>循环块</strong>的子块，if 执行语句是整个 <strong>if 块</strong>的子块</li>
<li>函数定义不同。函数头与函数体同级，同属一个<strong>函数块</strong>，函数形参在函数体里不会被隐藏。</li>
</ul>
</li>
<li><p>声明自动变量：1. 在块里声明的变量默认为自动变量；2. 显示声明可用 auto 关键字在声明前，但与 c++ 会冲突。</p>
</li>
</ul>
<h4 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h4><ul>
<li><p>声明方式：前加 register 关键字，eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> quick;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">macho</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄存器变量不能通过地址访问，只能通过变量名访问；</p>
</li>
<li><p>寄存器变量也是块作用域、静态存储期、无链接；</p>
</li>
<li><p>寄存器变量不一定在寄存器里，看请求是否被批准；寄存器不一定存得下 double 等变量；</p>
</li>
</ul>
<h4 id="块作用域的静态变量"><a href="#块作用域的静态变量" class="headerlink" title="块作用域的静态变量"></a>块作用域的静态变量</h4><p>静态变量（static variable），块作用域（block scope）</p>
<ul>
<li>定义：在花括号（包括函数）内用 static 声明的变量；不能在函数形参里使用static；</li>
<li>静态指在程序运行期间一直存在；又叫局部静态变量；</li>
<li>在函数体内声明初始化块作用域静态变量的语句，只在程序被载入内存时执行一次，程序运行时不会执行；</li>
</ul>
<h4 id="外部链接的静态变量"><a href="#外部链接的静态变量" class="headerlink" title="外部链接的静态变量"></a>外部链接的静态变量</h4><h5 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h5><p>外部链接的静态变量 (static variables with external linkage)具有文件作用域、外部链接、静态存储期；</p>
<p>该类别有时被称为外部存储类别 (external storage class)，属于该类别的变量被称为**外部变量 (external variables)**；</p>
<p>定义：在所有函数外定义的变量就是外部变量；</p>
<p>声明：要使外部变量被其它文件可用，就要用 extern 声明；本文件里可声明可不声明；</p>
<p>隐藏：在函数内不加 extern 定义自动存储期同名变量，编译器会隐藏外部变量；</p>
<p>位置：在定义&#x2F;声明后的函数才可用外部变量；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Errupt;</span><br><span class="line"><span class="type">double</span> Up[<span class="number">100</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> Errupt;  <span class="comment">//可选声明</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">double</span> Up[];  <span class="comment">//可选声明，不用指定数组大小</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-初始化外部变量"><a href="#1-初始化外部变量" class="headerlink" title="1. 初始化外部变量"></a>1. 初始化外部变量</h5><p>只能用常量表达式初始化文件作用域变量；如果未被初始化，会被自动初始化为0</p>
<h5 id="2-使用外部变量"><a href="#2-使用外部变量" class="headerlink" title="2. 使用外部变量"></a>2. 使用外部变量</h5><h5 id="3-外部名称"><a href="#3-外部名称" class="headerlink" title="3. 外部名称"></a>3. 外部名称</h5><p>旧标准：编译器识别局部标识符前 31 个字符、外部标识符前 6 个字符；</p>
<p>C99 和 C11 标准：编译器识别局部标识符前 63 个字符、外部标识符前 31 个字符；</p>
<h5 id="4-定义和声明"><a href="#4-定义和声明" class="headerlink" title="4. 定义和声明"></a>4. 定义和声明</h5><p>定义和声明都是声明；</p>
<p>定义：定义式声明 (difining declaration)，为变量预留内存空间，<strong>不能用 extern 进行定义式声明</strong>，定义式声明只能有一个；</p>
<p>声明：引用式声明 (referencing declaration)，告诉编译器将使用该变量，<strong>extern 只能用在引用式声明</strong>，引用式声明可以有多个；</p>
<p>在整个程序中，只能在一个文件里并初始化一次；<strong>但是可以为外部变量随意赋值</strong>。</p>
<h3 id="内部链接的静态变量"><a href="#内部链接的静态变量" class="headerlink" title="内部链接的静态变量"></a>内部链接的静态变量</h3><p>内部链接的静态变量 (static variables with internal linkage)：文件作用域、内部链接、静态存储区；</p>
<p>这种变量也被称为<strong>外部静态变量 (external static variables)</strong></p>
<p>定义方式：用 static 关键字在所有函数外定义该变量，eg：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> svil = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存储类别说明符"><a href="#存储类别说明符" class="headerlink" title="存储类别说明符"></a>存储类别说明符</h3><p>6 个存储类别说明符：auto, static, extern, register, _Thread_local, typedef;</p>
<table>
<thead>
<tr>
<th>说明符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td></td>
</tr>
<tr>
<td>static</td>
<td></td>
</tr>
<tr>
<td>extern</td>
<td></td>
</tr>
</tbody></table>
<h2 id="函数的存储类别"><a href="#函数的存储类别" class="headerlink" title="函数的存储类别"></a>函数的存储类别</h2><p>函数也有存储类别：外部函数（默认）、静态函数、内联函数（C99 新增）；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">gamma</span><span class="params">(<span class="type">double</span>)</span>;  <span class="comment">//默认为外部函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">beta</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;  <span class="comment">//静态函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> <span class="title function_">delta</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>)</span>;  <span class="comment">//外部函数</span></span><br></pre></td></tr></table></figure>

<p>外部函数（默认、extern 声明）可以被其他文件访问；内部函数（static 声明）只能用于其定义所在的文件，避免函数名重复。</p>
<h1 id="ANSI-C-类型限定符-type-qualifiers"><a href="#ANSI-C-类型限定符-type-qualifiers" class="headerlink" title="ANSI C 类型限定符 type qualifiers"></a>ANSI C 类型限定符 type qualifiers</h1><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>类型 (type)、存储类别 (storage class)、类型限定符 (type qualifiers)</p>
<p>C90 新增：const (恒常性 constancy)，volatile (易变性 volatility)；</p>
<p>C99 新增：restrict；</p>
<p>C11 新增：_Atomic，可选库 stdatomic.h，幂等的 (idempotent)；</p>
<p>幂等的，可以一条声明多次使用同一个限定符，多余的限定符会被忽略。</p>
<h3 id="const-type-qualifiers"><a href="#const-type-qualifiers" class="headerlink" title="const type qualifiers"></a>const type qualifiers</h3><p>const 关键字声明的变量，只能在初始化时设定值，后续不能赋值或递增、递减来改变变量的值。</p>
<h4 id="1-在指针声明和形参声明中使用-const"><a href="#1-在指针声明和形参声明中使用-const" class="headerlink" title="1. 在指针声明和形参声明中使用 const"></a>1. 在指针声明和形参声明中使用 const</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p1;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p2;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p3;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p4;</span><br></pre></td></tr></table></figure>

<p>p1 和 p2 是指向 const int 的指针，const 修饰 int，p1 和 p2 能够改变指向，但不能改变指向的对象的值；</p>
<p>p3 是指向 int 的 const 指针，const 修饰 p3，p3 不能改变指向，但能够改变指向的对象的值；</p>
<p>p4 是指向 const int 的 const 指针；</p>
<p>总之，当 const 放在 * 左边，不能改变指针指向对象的值；当 const 放在 * 右边，指针不能指向别处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">( <span class="type">const</span> <span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> limit)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-对全局数据使用-const"><a href="#2-对全局数据使用-const" class="headerlink" title="2. 对全局数据使用 const"></a>2. 对全局数据使用 const</h4><p>两种方法：</p>
<ol>
<li><p>在一个文件使用定义式声明，其他文件中使用引用式声明 (用 extern)；</p>
</li>
<li><p>使用<strong>内部链接</strong>的全局变量时（外部链接会冲突），在头文件中定义全局变量，在其他文件中包含该头文件，就可自动定义；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//constant.h</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"><span class="comment">//file1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;constant.h&quot;</span></span></span><br><span class="line"><span class="comment">//file2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;constant.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="volatile-type-qualifiers"><a href="#volatile-type-qualifiers" class="headerlink" title="volatile type qualifiers"></a>volatile type qualifiers</h3><p>volatile 表示代理可以改变该变量的值；</p>
<p>告知编译器，编译器可针对优化。</p>
<h3 id="restrict-type-qualifiers"><a href="#restrict-type-qualifiers" class="headerlink" title="restrict type qualifiers"></a>restrict type qualifiers</h3><p>只能用于指针声明，表示只能通过该指针访问声明的对象；</p>
<p>告知编译器，编译器可针对优化。</p>
<h3 id="Atomic-type-qualifiers"><a href="#Atomic-type-qualifiers" class="headerlink" title="_Atomic type qualifiers"></a>_Atomic type qualifiers</h3><p>多线程编程时使用。当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。</p>
<h3 id="旧关键字的新位置"><a href="#旧关键字的新位置" class="headerlink" title="旧关键字的新位置"></a>旧关键字的新位置</h3><p>C99 新增</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ofmouth</span><span class="params">(<span class="type">int</span> al[<span class="type">const</span>], <span class="type">int</span> a2[<span class="keyword">restrict</span>], <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>新的 static 用法，告诉编译器如何使用形式参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">stick</span><span class="params">(<span class="type">double</span> ar[<span class="type">static</span> <span class="number">20</span>])</span>;</span><br></pre></td></tr></table></figure>

<h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/c/numeric/random">伪随机数生成</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 函数原型都在stdlib.h</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">( <span class="type">unsigned</span> seed )</span>;</span><br><span class="line"># 以值 seed 播种 rand() 所用的随机数生成器。</span><br><span class="line"># 若在任何到 srand() 的调用前使用 rand() ，则 rand() 表现为如同它被以 srand(<span class="number">1</span>) 播种。</span><br><span class="line"># 每次以同一 seed 播种 rand() 时，它必须产生相同的值数列。</span><br><span class="line"># 标准实践是使用以 time(<span class="number">0</span>) 为种子调用的结果。然而 time() 返回 <span class="type">time_t</span> 值，而不保证 <span class="type">time_t</span> 是整数类型。尽管实践中，主流实现都定义 <span class="type">time_t</span> 为整数类型，且此亦为 POSIX 所要求。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">()</span>;</span><br><span class="line"># 返回 <span class="number">0</span> 与 RAND_MAX（常常是INT_MAX） 间的随机整数值（包含 <span class="number">0</span> 与 RAND_MAX ）。</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line">rand();</span><br></pre></td></tr></table></figure>

<h1 id="time-h时间"><a href="#time-h时间" class="headerlink" title="time.h时间"></a><code>time.h</code>时间</h1><p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/c/chrono">日期和时间工具</a></p>
<ul>
<li><code>time_t</code></li>
</ul>
<p>足以表示时间的算术 (C11 前)实数 (C11 起)类型。</p>
<p>尽管 C 标准没有定义，它几乎总是一个保有从 UTC 1970 年 1 月 1 日 00:00 开始秒数的整数值（不计闰秒），对应 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix_time">POSIX 时间</a></p>
<ul>
<li><code>clock_t clock(void)</code></li>
</ul>
<p>返回从关联到进程开始执行的实现定义时期的起，进程所用的粗略处理器时间。将此值除以 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/c/chrono/CLOCKS_PER_SEC">CLOCKS_PER_SEC</a> 可转换为秒。只有两次对 <code>clock</code> 不同调用的返回值的差是有意义的，</p>
<ul>
<li>clock_t</li>
</ul>
<p>足以表示进程所用的处理器时间的算术 (C11 前)实数 (C11 起)类型。它拥有实现定义的范围和精度。</p>
<h1 id="gcc带颜色"><a href="#gcc带颜色" class="headerlink" title="gcc带颜色"></a>gcc带颜色</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在.bashrc里设置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">colored GCC warnings and errors</span></span><br><span class="line">export GCC_COLORS=&#x27;error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><ul>
<li>-c	Compile and assemble, but do not link.</li>
<li>编译 include 了 math.h 的头文件时，要加 -lm 选项，即：gcc -o 15_atoi 15_atoi.c -lm</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">	source(源文件 hello.c)--预处理preprocessing gcc -E  hello.c -o hello.i--&gt;i(预编译后文件 hello.i)--编译comlilation gcc -S  hello.i -o hello.s --&gt;S(汇编源程序文件 hello.s)--汇编assemble gcc -c hello.s -o hello.o --&gt;o(目标文件 hello.o)--链接 gcc hello.o -o hello --&gt;e(可执行文件)</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">illyber</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/28/c-notes/">http://example.com/2023/01/28/c-notes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">MyBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/28/git-notes/" title="Git notes"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Git notes</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/28/data-structure-and-algorithm/" title="data structure and algorithm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">data structure and algorithm</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">illyber</div><div class="author-info__description">学习计算机的记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-version"><span class="toc-number">1.</span> <span class="toc-text">C version</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E4%B8%80%E8%A7%88"><span class="toc-number">2.1.</span> <span class="toc-text">大小一览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">整型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bool%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">_Bool类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size-t-size-type"><span class="toc-number">2.2.3.</span> <span class="toc-text">size_t (size type)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time-t"><span class="toc-number">2.2.4.</span> <span class="toc-text">time_t</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6-x2F-%E5%AD%97%E7%AC%A6%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">字符&#x2F;字符变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">字符函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-x2F-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="toc-number">2.5.</span> <span class="toc-text">字符串&#x2F;字符数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%97%E8%A1%A8"><span class="toc-number">2.6.1.</span> <span class="toc-text">字符串列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97-P313"><span class="toc-number">2.6.2.</span> <span class="toc-text">把字符串转换为数字 P313</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.8.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.8.1.</span> <span class="toc-text">数字数组初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.8.2.</span> <span class="toc-text">字符数组初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.9.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">2.10.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8B%B1%E8%AF%AD%E8%AF%BB%E6%B3%95"><span class="toc-number">2.10.1.</span> <span class="toc-text">英语读法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#printf-%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.10.2.</span> <span class="toc-text">printf()转换类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9B%B8%E5%87%8F"><span class="toc-number">2.10.3.</span> <span class="toc-text">指针相减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%8814-13-P412%EF%BC%89"><span class="toc-number">2.10.4.</span> <span class="toc-text">指针与数组（14.13 P412）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.10.5.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.10.6.</span> <span class="toc-text">const 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88structure%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">结构体（structure）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9E%84%E6%A0%B7%E5%BC%8F%E3%80%81%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F%E3%80%81%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98"><span class="toc-number">2.11.1.</span> <span class="toc-text">1. 设置结构样式、定义结构变量、访问结构体成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%89%E7%A7%8D%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.11.2.</span> <span class="toc-text">2. 三种定义结构体变量的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F"><span class="toc-number">2.11.3.</span> <span class="toc-text">3. 初始化结构体变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-number">2.11.4.</span> <span class="toc-text">4. 结构数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84"><span class="toc-number">2.11.5.</span> <span class="toc-text">5. 嵌套结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8C%87%E9%92%88"><span class="toc-number">2.11.6.</span> <span class="toc-text">6. 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">2.11.7.</span> <span class="toc-text">7. 向函数传递结构的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%88%E7%BB%93%E6%9E%84%E4%BD%93%E5%B8%B8%E9%87%8F%EF%BC%89-C99"><span class="toc-number">2.11.8.</span> <span class="toc-text">8. 结构体的复合字面量（结构体常量）(C99)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BC%B8%E7%BC%A9%E5%9E%8B%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98%EF%BC%88C99%EF%BC%89"><span class="toc-number">2.11.9.</span> <span class="toc-text">9. 伸缩型数组成员（C99）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84-C11"><span class="toc-number">2.11.10.</span> <span class="toc-text">10. 匿名结构 (C11)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">2.11.11.</span> <span class="toc-text">11. 保存结构到文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="toc-number">2.11.12.</span> <span class="toc-text">12. 指定初始化器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%EF%BC%88union%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.12.</span> <span class="toc-text">联合（union）数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%88enumerated-type%EF%BC%89"><span class="toc-number">2.13.</span> <span class="toc-text">枚举（enumerated type）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%EF%BC%88P410%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">共享名称空间（P410）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8B-2-1-C%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8"><span class="toc-number">3.1.</span> <span class="toc-text">表B.2.1 C运算符优先级表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.</span> <span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#continue-%E4%B8%8E-break"><span class="toc-number">4.1.</span> <span class="toc-text">continue 与 break</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%EF%BC%88function%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">函数（function）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0-P311"><span class="toc-number">5.1.</span> <span class="toc-text">命令行参数 P311</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9Amalloc-calloc-free"><span class="toc-number">6.</span> <span class="toc-text">内存分配：malloc() calloc() free()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-exit-free"><span class="toc-number">6.1.</span> <span class="toc-text">malloc(), exit(), free()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.1.0.1.</span> <span class="toc-text">malloc 的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exit"><span class="toc-number">6.1.0.2.</span> <span class="toc-text">exit()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calloc-%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">calloc() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-number">6.3.</span> <span class="toc-text">动态内存分配和变长数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">6.4.</span> <span class="toc-text">存储类别和动态内存分配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">7.</span> <span class="toc-text">输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">7.1.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-x2F-O-%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">7.2.</span> <span class="toc-text">I&#x2F;O 示意图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E9%94%AE%E7%9B%98-I-x2F-O"><span class="toc-number">7.3.</span> <span class="toc-text">屏幕键盘 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.1.</span> <span class="toc-text">I&#x2F;O函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E"><span class="toc-number">7.3.2.</span> <span class="toc-text">转换说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.3.3.</span> <span class="toc-text">转换说明修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="toc-number">7.3.4.</span> <span class="toc-text">输出特殊字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6-I-x2F-O"><span class="toc-number">7.4.</span> <span class="toc-text">磁盘文件 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">7.4.1.</span> <span class="toc-text">文本文件与二进制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E8%A1%8C%E4%B8%8E%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE"><span class="toc-number">7.4.2.</span> <span class="toc-text">换行与文件结尾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fopen-%E5%92%8C-fclose"><span class="toc-number">7.4.3.</span> <span class="toc-text">fopen() 和 fclose()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fopen-%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">7.4.4.</span> <span class="toc-text">fopen()的模式字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fseek-%E5%92%8C-ftell"><span class="toc-number">7.4.5.</span> <span class="toc-text">fseek() 和 ftell()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fgetpos-%E5%92%8Cfsetpos"><span class="toc-number">7.4.6.</span> <span class="toc-text">fgetpos()和fsetpos()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rewind"><span class="toc-number">7.4.7.</span> <span class="toc-text">rewind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E6%98%AF%E6%80%8E%E4%B9%88%E7%A7%BB%E5%8A%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">7.4.8.</span> <span class="toc-text">文件指针是怎么移动的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O-%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.9.</span> <span class="toc-text">I&#x2F;O 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fread-x2F-fwrite"><span class="toc-number">7.4.9.1.</span> <span class="toc-text">fread&#x2F;fwrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-x2F-put%E7%B1%BB%E5%87%BD%E6%95%B0%EF%BC%88%E5%AD%97%E7%AC%A6-x2F-%E5%AD%97%E7%AC%A6%E4%B8%B2-I-x2F-O%EF%BC%89"><span class="toc-number">7.4.9.2.</span> <span class="toc-text">get&#x2F;put类函数（字符&#x2F;字符串 I&#x2F;O）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scanf-x2F-printf%E7%B1%BB%E5%87%BD%E6%95%B0%EF%BC%88%E6%A0%BC%E5%BC%8F%E5%8C%96I-x2F-O%EF%BC%89"><span class="toc-number">7.4.9.3.</span> <span class="toc-text">scanf&#x2F;printf类函数（格式化I&#x2F;O）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.9.4.</span> <span class="toc-text">其它函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-x2F-O-%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93"><span class="toc-number">7.5.</span> <span class="toc-text">I&#x2F;O 函数总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fread-x2F-fwrite-1"><span class="toc-number">7.5.1.</span> <span class="toc-text">fread&#x2F;fwrite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-x2F-put%E7%B1%BB%E5%87%BD%E6%95%B0%EF%BC%88%E5%AD%97%E7%AC%A6-x2F-%E5%AD%97%E7%AC%A6%E4%B8%B2-I-x2F-O%EF%BC%89-1"><span class="toc-number">7.5.2.</span> <span class="toc-text">get&#x2F;put类函数（字符&#x2F;字符串 I&#x2F;O）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scanf-x2F-printf%E7%B1%BB%E5%87%BD%E6%95%B0%EF%BC%88%E6%A0%BC%E5%BC%8F%E5%8C%96I-x2F-O%EF%BC%89-1"><span class="toc-number">7.5.3.</span> <span class="toc-text">scanf&#x2F;printf类函数（格式化I&#x2F;O）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0-1"><span class="toc-number">7.5.4.</span> <span class="toc-text">其它函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">位操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.</span> <span class="toc-text">进制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.2.</span> <span class="toc-text">按位逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.3.</span> <span class="toc-text">移位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%AD%97%E6%AE%B5%EF%BC%88%E4%BD%8D%E5%9F%9F%EF%BC%89%EF%BC%88bitfields%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">位字段（位域）（bitfields）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">C 预处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef%EF%BC%88P411%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">typedef（P411）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define"><span class="toc-number">9.2.</span> <span class="toc-text">#define</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include"><span class="toc-number">9.3.</span> <span class="toc-text">#include</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83def%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">9.4.</span> <span class="toc-text">其它def预处理指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">9.5.</span> <span class="toc-text">预定义宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#line"><span class="toc-number">9.6.</span> <span class="toc-text">#line</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error"><span class="toc-number">9.7.</span> <span class="toc-text">#error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pragma"><span class="toc-number">9.8.</span> <span class="toc-text">#pragma</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generic"><span class="toc-number">9.9.</span> <span class="toc-text">_Generic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%88inline-function-C99"><span class="toc-number">9.10.</span> <span class="toc-text">内联函数（inline function)(C99)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Noreturn"><span class="toc-number">9.11.</span> <span class="toc-text">_Noreturn</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%BA%93"><span class="toc-number">10.</span> <span class="toc-text">C 库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2-void%E6%8C%87%E9%92%88"><span class="toc-number">10.1.</span> <span class="toc-text">历史-void指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%BA%93"><span class="toc-number">10.2.</span> <span class="toc-text">数学库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-number">10.3.</span> <span class="toc-text">通用工具库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Assert-Library"><span class="toc-number">10.4.</span> <span class="toc-text">The Assert Library</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%9C%9F-storage-duration"><span class="toc-number">10.4.1.</span> <span class="toc-text">存储期 storage duration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.4.1.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="toc-number">10.4.1.2.</span> <span class="toc-text">自动变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E9%87%8F"><span class="toc-number">10.4.1.3.</span> <span class="toc-text">寄存器变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">10.4.1.4.</span> <span class="toc-text">块作用域的静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">10.4.1.5.</span> <span class="toc-text">外部链接的静态变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-number">10.4.1.5.1.</span> <span class="toc-text">定义与声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">10.4.1.5.2.</span> <span class="toc-text">1. 初始化外部变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">10.4.1.5.3.</span> <span class="toc-text">2. 使用外部变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%A4%96%E9%83%A8%E5%90%8D%E7%A7%B0"><span class="toc-number">10.4.1.5.4.</span> <span class="toc-text">3. 外部名称</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="toc-number">10.4.1.5.5.</span> <span class="toc-text">4. 定义和声明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">10.4.2.</span> <span class="toc-text">内部链接的静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">10.4.3.</span> <span class="toc-text">存储类别说明符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">10.5.</span> <span class="toc-text">函数的存储类别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ANSI-C-%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6-type-qualifiers"><span class="toc-number">11.</span> <span class="toc-text">ANSI C 类型限定符 type qualifiers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E8%A7%88"><span class="toc-number">11.0.1.</span> <span class="toc-text">总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-type-qualifiers"><span class="toc-number">11.0.2.</span> <span class="toc-text">const type qualifiers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8%E6%8C%87%E9%92%88%E5%A3%B0%E6%98%8E%E5%92%8C%E5%BD%A2%E5%8F%82%E5%A3%B0%E6%98%8E%E4%B8%AD%E4%BD%BF%E7%94%A8-const"><span class="toc-number">11.0.2.1.</span> <span class="toc-text">1. 在指针声明和形参声明中使用 const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8-const"><span class="toc-number">11.0.2.2.</span> <span class="toc-text">2. 对全局数据使用 const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-type-qualifiers"><span class="toc-number">11.0.3.</span> <span class="toc-text">volatile type qualifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#restrict-type-qualifiers"><span class="toc-number">11.0.4.</span> <span class="toc-text">restrict type qualifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic-type-qualifiers"><span class="toc-number">11.0.5.</span> <span class="toc-text">_Atomic type qualifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A7%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%96%B0%E4%BD%8D%E7%BD%AE"><span class="toc-number">11.0.6.</span> <span class="toc-text">旧关键字的新位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">随机数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#time-h%E6%97%B6%E9%97%B4"><span class="toc-number">13.</span> <span class="toc-text">time.h时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gcc%E5%B8%A6%E9%A2%9C%E8%89%B2"><span class="toc-number">14.</span> <span class="toc-text">gcc带颜色</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">15.</span> <span class="toc-text">编译过程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/19/btrfs-notes/" title="无题">无题</a><time datetime="2023-06-18T20:11:40.252Z" title="发表于 2023-06-19 04:11:40">2023-06-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/19/package-manager-notes/" title="无题">无题</a><time datetime="2023-06-18T20:11:40.252Z" title="发表于 2023-06-19 04:11:40">2023-06-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/15/shell-and-regexp-notes/" title="Shell和正则表达式">Shell和正则表达式</a><time datetime="2023-06-15T07:59:16.786Z" title="发表于 2023-06-15 15:59:16">2023-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/06/css-notes/" title="CSS notes">CSS notes</a><time datetime="2023-02-06T05:56:44.000Z" title="发表于 2023-02-06 13:56:44">2023-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/02/vscode-notes/" title="Vscode notes">Vscode notes</a><time datetime="2023-02-02T15:49:24.000Z" title="发表于 2023-02-02 23:49:24">2023-02-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By illyber</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>